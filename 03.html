

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>The Power Spectrum (Part 1) &#8212; Case Studies in Neural Data Analysis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/mystnb.js"></script>
    <script src="_static/custom.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script async="async" src="_static/thebelab.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="canonical" href="https://mark-kramer.github.io/Case-Studies-Python/03.html" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Power Spectrum (Part 2)" href="04.html" />
    <link rel="prev" title="The Event-Related Potential" href="02.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">


<!-- Opengraph tags -->
<meta property="og:url"         content="https://mark-kramer.github.io/Case-Studies-Python/03.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="The Power Spectrum (Part 1)" />
<meta property="og:description" content="The Power Spectrum (Part 1)  <div class="question">   Synopsis  Data: 2 s of scalp EEG data sampled at 1000 Hz.  Goal: Characterize the observed rhythms in thes" />
<meta property="og:image"       content="https://mark-kramer.github.io/Case-Studies-Python/_static/logo.png" />

<meta name="twitter:card" content="summary">


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Case Studies in Neural Data Analysis</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="01.html">1. Python for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="02.html">2. The Event-Related Potential</a>
  </li>
  <li class="active">
    <a href="">3. The Power Spectrum (Part 1)</a>
  </li>
  <li class="">
    <a href="04.html">4. The Power Spectrum (Part 2)</a>
  </li>
  <li class="">
    <a href="05.html">5. Analysis of Coupled Rhythms</a>
  </li>
  <li class="">
    <a href="06.html">6. Filtering Field Data</a>
  </li>
  <li class="">
    <a href="07.html">7. Cross-Frequency Coupling</a>
  </li>
  <li class="">
    <a href="08.html">8. Basic Analysis of Spike Train Data</a>
  </li>
  <li class="">
    <a href="09.html">9. Point Process Generalized Linear Models</a>
  </li>
  <li class="">
    <a href="10.html">10. Analysis of Rhythmic Spike Train Data</a>
  </li>
  <li class="">
    <a href="11.html">11. Spike-Field Coherence</a>
  </li>
<li class="navbar-special">
<p class="margin-caption">Extra notebooks</p>
</li>
  <li class="">
    <a href="IF.html">12. The integrate and fire neuron</a>
  </li>
  <li class="">
    <a href="HH.html">13. The Hodgkin-Huxley model</a>
  </li>
  <li class="">
    <a href="Perceptron.html">14. Training a Perceptron</a>
  </li>
  <li class="">
    <a href="Backprop.html">15. Backpropagation</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="_sources/03.ipynb"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.ipynb</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Source interaction buttons -->
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
            <div class="dropdown-buttons sourcebuttons">
                <a class="repository-button" href="https://github.com/Mark-Kramer/Case-Studies-Python/"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left" title="Source repository"><i class="fab fa-github"></i>repository</button></a>
                <a class="issues-button" href="https://github.com/Mark-Kramer/Case-Studies-Python//issues/new?title=Issue%20on%20page%20%2F03.html&body=Your%20issue%20content%20here."><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left" title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
                
            </div>
        </div>
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
            <div class="dropdown-buttons">
                
                <a class="binder-button" href="https://mybinder.org/v2/gh/Mark-Kramer/Case-Studies-Python/binder?urlpath=tree/03.ipynb"><button type="button" class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip" data-placement="left"><img class="binder-button-logo" src="_static/images/logo_binder.svg" alt="Interact on binder">Binder</button></a>
                
                
                <button type="button" class="btn btn-secondary topbarbtn thebelab-launch-button" onclick="initThebelab()" title="Launch Thebelab" data-toggle="tooltip" data-placement="left"><i class="fas fa-rocket"></i><span style="margin-left: .4em;">ThebeLab</span></button>
                
            </div>
        </div>
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#on-ramp-computing-the-spectrum-in-python" class="nav-link">On-ramp: computing the  spectrum in Python</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#introduction" class="nav-link">Introduction</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#case-study-data" class="nav-link">Case study data</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#goals" class="nav-link">Goals</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#tools" class="nav-link">Tools</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#data-analysis" class="nav-link">Data analysis</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-1-visual-inspection" class="nav-link">Step 1: Visual inspection</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-2-mean-variance-and-standard-deviation" class="nav-link">Step 2: Mean, variance, and standard deviation</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-3-the-autocovariance" class="nav-link">Step 3: The autocovariance</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-4-power-spectral-density-or-spectrum" class="nav-link">Step 4: Power spectral density, or spectrum</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#discrete-fourier-transform-in-python" class="nav-link">Discrete Fourier Transform in Python</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#the-nyquist-frequency" class="nav-link">The Nyquist frequency</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#the-frequency-resolution" class="nav-link">The frequency resolution</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-5-decibel-scaling" class="nav-link">Step 5: Decibel scaling</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#step-6-the-spectrogram" class="nav-link">Step 6: The spectrogram</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <p><a id="top"></a></p>
<div class="section" id="the-power-spectrum-part-1">
<h1>The Power Spectrum (Part 1)<a class="headerlink" href="#the-power-spectrum-part-1" title="Permalink to this headline">¶</a></h1>
<div class="question">
<p><em><strong>Synopsis</strong></em></p>
<p><strong>Data:</strong> 2 s of scalp EEG data sampled at 1000 Hz.</p>
<p><strong>Goal:</strong> Characterize the observed rhythms in these data.</p>
<p><strong>Tools:</strong> Fourier transform, power spectral density, spectrogram.</p>
</div><ul class="simple">
<li><p><a class="reference external" href="#onramp">On-ramp</a></p></li>
<li><p><a class="reference external" href="#intro">Introduction</a></p></li>
<li><p><a class="reference external" href="#data-analysis">Data analysis</a></p>
<ol class="simple">
<li><p><a class="reference external" href="#visual-inspection">Visual inspection</a></p></li>
<li><p><a class="reference external" href="#mean">Mean, variance, and standard deviation</a></p></li>
<li><p><a class="reference external" href="#autocovariance">The autocovariance</a></p></li>
<li><p><a class="reference external" href="#power-spectral-density">Power spectral density</a></p>
<ul>
<li><p><a class="reference external" href="#spectrum">The spectrum</a></p></li>
<li><p><a class="reference external" href="#dft">The discrete Fourier transform in Python</a></p></li>
<li><p><a class="reference external" href="#nyquist-frequency">The Nyquist frequency</a></p></li>
<li><p><a class="reference external" href="#frequency-resolution">The frequency resolution</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#decibel-scaling">Decibel scaling</a></p></li>
<li><p><a class="reference external" href="#the-spectrogram">The spectrogram</a></p></li>
</ol>
</li>
<li><p><a class="reference external" href="#summary">Summary</a></p></li>
<li><p><a class="reference external" href="#donate">Donate</a></p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p><a class="reference external" href="#supplements">Supplements</a></p>
<ol class="simple">
<li><p><a class="reference external" href="#supplement-acv">Biased versus unbiased autocovariance</a></p></li>
<li><p><a class="reference external" href="#supplement-psd">Intuition behind the power spectral density</a></p></li>
</ol>
</li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the usual suspects ...</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span>                    <span class="c1"># To load .mat files</span>
<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>                             <span class="c1"># Import plotting functions</span>
<span class="kn">from</span> <span class="nn">IPython.lib.display</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>    <span class="c1"># Package for displaying YouTube videos</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ... and the tools that we will need for this notebook</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">where</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">rfft</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">spectrogram</span>
<span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>               <span class="c1"># Change the default figure size</span>
</pre></div>
</div>
</div>
</div>
<div class="python-note">
<p>Note that the NumPy functions imported in the second cell were already imported as part of pylab. We explicitly imported them again so that it’s clear that these functions are from the NumPy module.</p>
</div><p><a id="onramp"></a></p>
<div class="section" id="on-ramp-computing-the-spectrum-in-python">
<h2>On-ramp: computing the  spectrum in Python<a class="headerlink" href="#on-ramp-computing-the-spectrum-in-python" title="Permalink to this headline">¶</a></h2>
<p>We begin this notebook with an “<em>on-ramp</em>” to analysis. The purpose of this on-ramp is to introduce you immediately to a core concept in this notebook: how to compute a spectrum in Python. You may not understand all aspects of the program here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what <em>can</em> be done. Our advice is to simply run the code below and see what happens …</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/EEG-1.mat&#39;</span><span class="p">)</span>  <span class="c1"># Load the EEG data</span>
<span class="n">EEG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># Extract the EEG variable</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>                      <span class="c1"># ... and the t variable</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">EEG</span>                               <span class="c1"># Relabel the data variable</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                      <span class="c1"># Define the sampling interval</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                        <span class="c1"># Define the total number of data points</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">dt</span>                            <span class="c1"># Define the total duration of the data</span>

<span class="n">xf</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>                <span class="c1"># Compute Fourier transform of x</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">xf</span> <span class="o">*</span> <span class="n">xf</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>  <span class="c1"># Compute spectrum</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>           <span class="c1"># Ignore negative frequencies</span>

<span class="n">df</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">T</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>                      <span class="c1"># Determine frequency resolution</span>
<span class="n">fNQ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span>                      <span class="c1"># Determine Nyquist frequency</span>
<span class="n">faxis</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">fNQ</span><span class="p">,</span><span class="n">df</span><span class="p">)</span>              <span class="c1"># Construct frequency axis</span>

<span class="n">plot</span><span class="p">(</span><span class="n">faxis</span><span class="p">,</span> <span class="n">Sxx</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>                 <span class="c1"># Plot spectrum vs frequency</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>                        <span class="c1"># Select frequency range</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>              <span class="c1"># Label the axes</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [$\mu V^2$/Hz]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_7_0.png" src="_images/03_7_0.png" />
</div>
</div>
<div class="question">
<p><strong>Q:</strong> Try to read the code above. Can you see how it loads data, computes the spectrum, and then plots the results?</p>
<p><strong>A:</strong> If you’ve never computed a spectrum before, that’s an especially difficult question. Please continue on to learn this <strong>and more</strong>!</p>
</div><p><a id="intro"></a></p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;PmGme7YuAiw&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/PmGme7YuAiw"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>In this notebook, we consider data recorded in the scalp <a href="https://en.wikipedia.org/wiki/Electroencephalography" rel="external">electroencephalogram</a> or EEG. The EEG provides a measure of brain voltage activity with high temporal resolution (typically on the order of milliseconds) but poor spatial resolution (on the order of 10 cm<sup>2</sup> of cortex). Here we will consider EEG activity recorded from a single scalp electrode. We will analyze these data to determine what (if any) rhythmic activity is present. In doing so, we will learn about an important technique to characterize rhythms in data - the Fourier transform and power spectral density or “spectrum” - and the many subtleties associated with this technique. We begin with a brief description of the data.</p>
<div class="section" id="case-study-data">
<h3>Case study data<a class="headerlink" href="#case-study-data" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;oRCUx11iEck&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/oRCUx11iEck"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>A patient enters the Massachusetts General Hospital (MGH) emergency room unconscious. As part of his clinical workup, electrodes are placed on the scalp surface and the EEG recorded. We assume that the skilled technicians at MGH record the EEG data with no artifacts (i.e., correctly placed electrodes in good electrical contact with the scalp). Twenty-one electrodes simultaneously record the EEG data for 10 minutes sampled at 1000 Hz (i.e., 1000 samples per second). To start, we receive from our clinical collaborator a 2 s snippet of EEG data recorded from a single electrode. If we find anything interesting in this 2 s snippet, our clinical collaborator has promised to provide additional EEG data from this patient and others.</p>
</div>
<div class="section" id="goals">
<h3>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;L0xf0dCn7T0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/L0xf0dCn7T0"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>The goal of this notebook is to analyze the 2 s of EEG data by characterizing the observed rhythms. By the end of this notebook, you should be familiar with the principles of the Fourier transform, how to compute the spectrum in Python, and the time-windowed spectrum.</p>
</div>
<div class="section" id="tools">
<h3>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h3>
<p>The primary tool developed in this notebook is the Fourier transform. We will learn how to compute the Fourier transform, and the associated spectrum, in Python. We will see that the spectrum provides a powerful technique to assess rhythmic structure in time series data.</p>
<p><a id="data-analysis"></a></p>
</div>
</div>
<div class="section" id="data-analysis">
<h2>Data analysis<a class="headerlink" href="#data-analysis" title="Permalink to this headline">¶</a></h2>
<p>We will go through the following steps to analyze the data:</p>
<ol class="simple">
<li><p><a class="reference external" href="#visual-inspection">Visual inspection</a></p></li>
<li><p><a class="reference external" href="#mean">Mean, variance, and standard deviation</a></p></li>
<li><p><a class="reference external" href="#autocovariance">The autocovariance</a></p></li>
<li><p><a class="reference external" href="#power-spectral-density">Power spectral density</a></p></li>
<li><p><a class="reference external" href="#decibel-scaling">Decibel scaling</a></p></li>
<li><p><a class="reference external" href="#the-spectrogram">The spectrogram</a></p></li>
</ol>
<p><a id="visual-inspection"></a></p>
</div>
<div class="section" id="step-1-visual-inspection">
<h2>Step 1: Visual inspection<a class="headerlink" href="#step-1-visual-inspection" title="Permalink to this headline">¶</a></h2>
<p>Often, the best place to begin our data analysis is visual inspection of the time series. To do so, let’s plot the data:<a id="fig:3.1"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/03_EEG-1.mat&#39;</span><span class="p">)</span> <span class="c1"># Load the EEG data</span>
<span class="n">EEG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span>                 <span class="c1"># Extract the EEG variable</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>                        <span class="c1"># ... and the t variable</span>

<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">EEG</span><span class="p">)</span>                            <span class="c1"># Plot the data versus time</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>                      <span class="c1"># Label the time axis</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage [$\mu V$]&#39;</span><span class="p">)</span>             <span class="c1"># ... and the voltage axis</span>
<span class="n">autoscale</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                   <span class="c1"># Minimize white space</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/3-1&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_21_0.png" src="_images/03_21_0.png" />
</div>
</div>
<div class="python-note">
<p><strong>Array shapes:</strong> The <code class="docutils literal notranslate"><span class="pre">reshape()</span></code> function lets us change the shape of an array. <code class="docutils literal notranslate"><span class="pre">reshape(-1)</span></code> tells Python to reshape the array into a vector with as many elements as are in the array. Mathematically, a vector is a one-dimensional array. In Python, the difference is that a vector is indexed by a single number, while an array is indexed by multiple numbers. After reshaping, we can look at the number at index 0 of <code class="docutils literal notranslate"><span class="pre">EEG</span></code> using <code class="docutils literal notranslate"><span class="pre">EEG[0]</span></code>. If we don’t reshape first, we need to use <code class="docutils literal notranslate"><span class="pre">EEG[0,</span> <span class="pre">0]</span></code> to get the same result, so reshaping the array isn’t required, but it is more convenient. There is a nice explanation of array shapes <a href="https://stackoverflow.com/questions/22053050/difference-between-numpy-array-shape-r-1-and-r#answer-22074424" rel="external">here</a>.</p>
</div><div class="question">
<p><strong>Q.</strong> What observations can you make about the EEG data?</p>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;GepHsNVXTN4&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/GepHsNVXTN4"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>You might notice, through visual inspection, a dominant rhythmic activity. We can approximate the frequency of this rhythm by counting the number of oscillations that occur in a 1 s interval. To do so, we might count the total number of maxima and divide by 2 (because we observe 2 seconds of data). However, counting so many maxima over an extended time interval is quite an error-prone procedure. Instead, let us count the number of maxima in the first 0.2 s, and then multiply by five; that will approximate the total number of peaks in a 1 s interval. We count about 12 peaks in the first 0.2 s, which corresponds to approximately 60 peaks in 1 s. That’s (approximately) 60 cycles per second or 60 Hertz (Hz).</p>
<div class="question">
<p><strong>Q.</strong> What if you counted the minima, instead of the maxima? Do you get the same answer? What if you counted the zero crossings?</p>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;mZ1uHN4lcPY&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/mZ1uHN4lcPY"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Visual inspection suggests a dominant rhythmic activity at a frequency of 60 Hz. With excitement we recall that high frequency oscillations in the 40-80 Hz band (the “<a href="https://en.wikipedia.org/wiki/Gamma_wave" rel="external">gamma band</a>”) are thought important for cognitive processing in the brain [<a href="https://doi.org/10.1016/j.tics.2012.12.003" rel="external">Nikolić, Fries, &amp; Singer, 2013</a>]. But, there’s a reason for the label gamma band: the rhythmic activity observed <em>in vivo</em> is typically diffuse, spread over a range of rhythms at neighboring frequencies. The rhythmic activity observed here is concentrated and remarkably regular for EEG data.</p>
<div class="warning">
<p><strong>Important fact:</strong> The alternating current in any North American electrical socket alternates at 60 Hz.</p>
</div>
<p>We conclude that the data are dominated by electrical noise and continue with additional analysis, beyond visual inspection of the time series data. Our visual inspection suggests a dominant 60 Hz signal, but perhaps something else is there, lurking in the signal background.</p>
<p>Sometimes visual inspection is enough, especially when something has gone wrong (e.g., if the EEG trace were zero for all time, we should be suspicious). But, looks can be deceiving. For one, the voltage trace is plotted as a continuous line, but that’s incorrect. If we look more closely, we find that the data consists of discrete points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;UVnpQVUqpWI&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/UVnpQVUqpWI"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">25</span><span class="p">],</span> <span class="n">EEG</span><span class="p">[:</span><span class="mi">25</span><span class="p">],</span> <span class="s1">&#39;o-&#39;</span><span class="p">)</span>    <span class="c1"># Plot the first 25 points of data,</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>              <span class="c1"># ... with axes labeled.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage [$\mu V$]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_29_0.png" src="_images/03_29_0.png" />
</div>
</div>
<p>Although the true brain signal may evolve as a continuous voltage trace in time, we do not observe this true signal. Instead, we observe a discrete sampling of this signal in time. The spacing between these samples is determined by the recording device collecting the EEG data. In this case, our collaborator has told us that the data are sampled at 1000 Hz, which corresponds to a sample of data every 1 ms. So, we observe not the (presumably) continuous true voltage signal, but instead discrete samples of this signal in time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;W9BTYZM8yzs&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/W9BTYZM8yzs"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>To understand the impact of this discrete sampling, we first require some definitions. Let’s define <span class="math notranslate nohighlight">\(\Delta\)</span> as the time between samples, in this case, <span class="math notranslate nohighlight">\(\Delta = 1\)</span> ms. We also define <span class="math notranslate nohighlight">\(N\)</span> as the total number of points observed, and <span class="math notranslate nohighlight">\(T\)</span> as the total time of the recording. These three terms are related:</p>
<p><span class="math notranslate nohighlight">\(T = N \Delta\)</span>.</p>
<p>For the <span class="math notranslate nohighlight">\(T = 2\)</span> s of EEG data, there are <span class="math notranslate nohighlight">\(N = T/dt = 2/0.001 = 2000\)</span> points. From this, we can also define the <strong>sampling frequency</strong></p>
<p><span class="math notranslate nohighlight">\(f_0 = 1/\Delta\)</span></p>
<p>which in this case is 1000 Hz. Finally, we define a symbol for the data, <span class="math notranslate nohighlight">\(x\)</span>, which we also write as <span class="math notranslate nohighlight">\(x_n\)</span> to explicitly indicate the index <span class="math notranslate nohighlight">\(n \in \{1, 2, 3, \ldots, N\}\)</span> corresponding to the sample number. Let’s also define all of these variables in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">EEG</span>           <span class="c1"># Relabel the data variable</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Define the sampling interval</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># Define the total number of data points</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">dt</span>        <span class="c1"># Define the total duration of the data</span>
</pre></div>
</div>
</div>
</div>
<p>We will need to keep the sampling interval <span class="math notranslate nohighlight">\(\Delta\)</span> and the total recording duration <span class="math notranslate nohighlight">\(T\)</span> in mind—both will serve fundamental roles in our characterization of the rhythmic activity.</p>
<div class="question">
<p><strong>Q.</strong> In the second line of the code above we define the sampling interval as <code class="docutils literal notranslate"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">t[1]</span> <span class="pre">-</span> <span class="pre">t[0]</span></code>. How else could we have defined <code class="docutils literal notranslate"><span class="pre">dt</span></code>? Would <code class="docutils literal notranslate"><span class="pre">t[10]</span> <span class="pre">-</span> <span class="pre">t[9]</span></code> be appropriate?</p>
</div><p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="mean"></a></p>
</div>
<div class="section" id="step-2-mean-variance-and-standard-deviation">
<h2>Step 2: Mean, variance, and standard deviation<a class="headerlink" href="#step-2-mean-variance-and-standard-deviation" title="Permalink to this headline">¶</a></h2>
<p>As a first step in our analysis of the EEG data, let’s define two of the simplest measures we can use to characterize data <span class="math notranslate nohighlight">\(x\)</span>: the mean and variance <sup><abbr title="We could instead write the sample mean, because we use the observed data to estimate the theoretical mean that we would see if we were to keep repeating this experiment. This distinction is not essential to our goals here, but is important when talking to your statistics-minded colleagues. Throughout this notebook and others, we omit the term “sample” when referring to sample means, variances, covariances, and so forth, unless this distinction becomes essential to our discussion."><em>note</em></abbr></sup>. To estimate the mean <span class="math notranslate nohighlight">\(\bar x\)</span>, or average value, of <span class="math notranslate nohighlight">\(x\)</span> we compute,</p>
<p title="Mean">
$$ 
  \bar x = \frac{1}{N}\sum_{n=1}^N x_n. 
$$
</p>
<p>In words, we sum the values of <span class="math notranslate nohighlight">\(x\)</span> for all <span class="math notranslate nohighlight">\(n\)</span> time indices, then divide by the total number of points summed (<span class="math notranslate nohighlight">\(N\)</span>). To estimate the variance <span class="math notranslate nohighlight">\(\sigma^2\)</span> of <span class="math notranslate nohighlight">\(x\)</span> we compute,</p>
<p title="Variance">
$$ 
  \sigma^2 = \frac{1}{N}\sum_{n=1}^N (x_n - \overline x)^2,
$$
</p>
<p>which characterizes the extent of fluctuations about the mean. The <em>standard deviation</em> is simply the square root of the variance (i.e., <span class="math notranslate nohighlight">\(\sigma\)</span>). It’s straightforward to compute all three quantities on an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mn</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># Compute the mean of the data</span>
<span class="n">vr</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>   <span class="c1"># Compute the variance of the data</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>   <span class="c1"># Compute the standard deviation of the data</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;mn = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;vr = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vr</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sd = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>mn = 2.731148640577885e-17
vr = 0.5047172407856452
sd = 0.7104345436320261
</pre></div>
</div>
</div>
</div>
<div class="python-note">
<p><strong>A note on data types:</strong> As used above, <code class="docutils literal notranslate"><span class="pre">mean()</span></code>, <code class="docutils literal notranslate"><span class="pre">var()</span></code>, and <code class="docutils literal notranslate"><span class="pre">std()</span></code> are methods of a type of variable called an <em>ndarray</em> (use <code class="docutils literal notranslate"><span class="pre">type(x)</span></code> to see what type of variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is). The SciPy <code class="docutils literal notranslate"><span class="pre">loadmat()</span></code> function automatically imports variables to this data type, but it is likely that you will end up working with other data types as well. If you find that <code class="docutils literal notranslate"><span class="pre">x.mean()</span></code> produces an error, <code class="docutils literal notranslate"><span class="pre">x</span></code> is probably not an ndarray. In this case, you should import the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> module and either convert your variable to an ndarray using <code class="docutils literal notranslate"><span class="pre">numpy.array(x)</span></code>, or calculate the mean using <code class="docutils literal notranslate"><span class="pre">numpy.mean(x)</span></code>.</p>
</div><div class="question">
<p><strong>Q.</strong> Compare the mean computed above with the plot of the EEG data. Are the two consistent? How does the standard deviation compare with the EEG fluctuations in the plot?</p>
<p><strong>A.</strong> The computed mean is approximately 0. Visual inspection of the plot suggests that the EEG data fluctuate around a center value of 0, so the computed mean is consistent with our visual inspection of the data. The computed standard deviation is approximately 0.71. We expect that most of the signal fluctuations lie within two standard deviations (i.e., <span class="math notranslate nohighlight">\(\pm 2\sigma\)</span>) of the mean. We therefore expect to observe EEG values mostly between 0 ± 1.4 = (−1.4, 1.4), which is in fact what we observe.</p>
</div><p>The mean and variance (and standard deviation) provide single numbers that summarize the EEG trace. In this case, these numbers are not particularly useful. Both may depend on many factors, including the electrical contact between the electrode and scalp surface, and the cognitive state of the subject. Here, we’re more interested in how the EEG activity is distributed across rhythms. We’ve already begun to assess rhythms in the EEG data through visual inspection of the time series. To further characterize these rhythms, we will employ another powerful tool - the Fourier transform. However, before introducing the Fourier transform, we’ll first consider an intimately related measure: the autocovariance.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="autocovariance"></a></p>
</div>
<div class="section" id="step-3-the-autocovariance">
<h2>Step 3: The autocovariance<a class="headerlink" href="#step-3-the-autocovariance" title="Permalink to this headline">¶</a></h2>
<p>Our visual inspection strongly suggests a prominent feature in the data—rhythmic activity. Rhythmic activity represents a type of dependent structure in the data. For example, if we know the data tends to oscillate near 60 Hz, then given the value of the EEG data now, we can accurately predict the value of the EEG data 1/60 s in the future (i.e., one cycle of the 60 Hz activity); it should
be similar. One technique to assess the dependent structure in the data is the autocovariance. To start, let’s write down the formula for the autocovariance, <span class="math notranslate nohighlight">\(r_{xx}[L]\)</span>, evaluated at lag <span class="math notranslate nohighlight">\(L\)</span>,</p>
<p><a id="eq:3.3"></a>
<span class="math notranslate nohighlight">\($
  r_{xx}[L] = \frac{1}{N}\sum_{n=1}^{N-L}(x_{n+L} - \bar x)(x_n - \bar x).
$\)</span></p>
<p>In words, the autocovariance multiplies the data <span class="math notranslate nohighlight">\(x\)</span> at index <span class="math notranslate nohighlight">\(n + L\)</span>, by the data <span class="math notranslate nohighlight">\(x\)</span> at index <span class="math notranslate nohighlight">\(n\)</span>, and sums these products over all indices <span class="math notranslate nohighlight">\(n\)</span>. Notice that, in both terms, the mean value <span class="math notranslate nohighlight">\(\bar x\)</span> is subtracted from <span class="math notranslate nohighlight">\(x\)</span> before computing the product, and we divide the resulting sum by the total number of data points in <span class="math notranslate nohighlight">\(x\)</span>. We note that this is a <em>biased</em> estimate of the autocovariance; we compare this to an unbiased estimate of the autocovariance in the supplement entitled <a class="reference external" href="#supplement-acv"><em>Biased versus unbiased autocovariance</em></a>.</p>
<p>To gain some intuition for the autocovariance, let’s represent <span class="math notranslate nohighlight">\(x\)</span> graphically as a one-dimensional row vector.</p>
<p><img alt="cartoon of a row vector" src="_images/3-3a.png" /></p>
<p>For the case <span class="math notranslate nohighlight">\(L = 0\)</span>, the autocovariance is simply the element-by-element product of x with itself, summed over all indices.</p>
<p><img alt="autocovariance at lag 0" src="_images/3-3b.png" /></p>
<p>For the case <span class="math notranslate nohighlight">\(L = 1\)</span>, we shift <span class="math notranslate nohighlight">\(x\)</span> by one index, multiply element-by-element the original (unshifted) <span class="math notranslate nohighlight">\(x\)</span> by the shifted version, and sum over all indices.</p>
<p><img alt="autocovariance at lag 1" src="_images/3-3c.png" /></p>
<p>This process of shifting, element-by-element multiplying, and summing can be repeated for both positive and negative values of the lag <span class="math notranslate nohighlight">\(L\)</span>. Notice that, for larger values of <span class="math notranslate nohighlight">\(L\)</span>, we lose values at the beginning and ends of the autocovariance.</p>
<p><img alt="autocovariance at lag 2" src="_images/3-3d.png" /></p>
<div class="question">
<p><strong>Q.</strong> What is the largest reasonable value of <span class="math notranslate nohighlight">\(L\)</span> to consider? For example, does a value of <span class="math notranslate nohighlight">\(L\)</span> greater than <span class="math notranslate nohighlight">\(N\)</span> make sense?</p>
</div><p>The autocovariance will be largest at the lag <span class="math notranslate nohighlight">\(L\)</span> for which the values of x “match”. For most functions, the autocovariance is largest at <span class="math notranslate nohighlight">\(L = 0\)</span> (of course <span class="math notranslate nohighlight">\(x\)</span> matches itself with zero shift) and tends to decrease as the magnitude of <span class="math notranslate nohighlight">\(L\)</span> increases. Physically, the decrease in autocovariance with lag is consistent with the notion that data becomes less similar as time progresses. For example, in an EEG recording, we expect the activity now to be similar to the activity in the immediate future, but different from the EEG activity in the more distant future; as the brain responds to different internal and external cues, we expect different EEG activities to emerge, and associations between the EEG activity now and later to decay. Functions <span class="math notranslate nohighlight">\(x\)</span> that exhibit dependent structure possess informative features in the autocovariance, as we’ll see for the EEG data in a moment.</p>
<div class="question">
<p><strong>Q.</strong> Compare the <a class="reference external" href="#autocovariance">autocovariance</a><a class="sup">eq<img src="imgs/03_eq_autocov.png"></a> at <span class="math notranslate nohighlight">\(L=0\)</span> and the <a class="reference external" href="#mean">standard deviation</a>.<a class="sup">eq<img src="imgs/03_eq_stdev.png"></a> Notice anything similar?</p>
</div><p>To compute the autocovariance of the EEG data, we execute the following commands<a id="fig:3-4a"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lags</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>    <span class="c1"># Compute the lags for the full autocovariance vector</span>
                                      <span class="c1"># ... and the autocov for L +/- 100 indices</span>
<span class="n">ac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">correlate</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="n">inds</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">100</span>               <span class="c1"># Find the lags that are within 100 time steps</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ac</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>       <span class="c1"># ... and plot them</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag [s]&#39;</span><span class="p">)</span>                     <span class="c1"># ... with axes labelled</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Autocovariance&#39;</span><span class="p">)</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/3-4a&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_46_0.png" src="_images/03_46_0.png" />
</div>
</div>
<div class="question">
<p><strong>Q.</strong> Examine the plot of the autocovariance of the EEG data. What do you observe?</p>
</div><p>Notice that the first input to the function <code class="docutils literal notranslate"><span class="pre">correlate</span></code> is the EEG data with the mean subtracted (<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">mean(x)</span></code>). One striking feature of the autocovariance is the periodicity. A careful inspection shows that the autocovariance exhibits repeated peaks and troughs approximately every 0.0166 s.</p>
<div class="question">
<p><strong>Q.</strong> Why does the autocovariance exhibit repeated peaks and troughs approximately every 0.0166 s?</p>
<p><strong>A.</strong> The autocovariance is reflective of the dominant rhythmic activity in the data. Remember that the EEG data are dominated by a 60 Hz rhythm.</p>
</div><p>To gain intuition for how this rhythmic activity affects the autocovariance, we can also plot examples of the EEG data <strong>aligned with different lags</strong> <span class="math notranslate nohighlight">\(L\)</span>. We’ll do so below in Python by examining different shifts of the 60 Hz cycle.</p>
<p>Let’s start by considering the case of <span class="math notranslate nohighlight">\(L=0\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>          <span class="c1"># Choose a subset of the data to plot</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">);</span>   <span class="c1"># Plot the original</span>
<span class="n">L</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>                       <span class="c1"># Choose the lag,</span>
                           <span class="c1"># ... and plot the shifted traces.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[[</span><span class="n">i</span> <span class="o">+</span> <span class="n">L</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span>
     <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend and informative title</span>
<span class="n">title</span><span class="p">(</span><span class="s2">&quot;Original time series data, and shifted by amount L</span><span class="se">\n</span><span class="s2">Autocovariance = </span><span class="si">{:.4}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">lags</span><span class="o">==</span><span class="n">L</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_50_0.png" src="_images/03_50_0.png" />
</div>
</div>
<p>At zero lag (<span class="math notranslate nohighlight">\(L = 0\)</span>), the two time series are identical. Therefore, the product</p>
<div class="math notranslate nohighlight">
\[
  (x_{n+0} - \bar x)(x_n - \bar x) = (x_n - \bar x)(x_n - \bar x) = (x_n - \bar x)^2
\]</div>
<p>is non-negative for all indices <span class="math notranslate nohighlight">\(n\)</span> (note that the product may sometimes be zero, but it’s never negative). To compute the autocovariance, we sum this product over all indices <span class="math notranslate nohighlight">\(n\)</span>, and divide by <span class="math notranslate nohighlight">\(N\)</span>, as defined in the equation for the autocovariance,</p>
<div class="math notranslate nohighlight">
\[
  r_{xx}[L] = \frac{1}{N}\sum_{n=1}^{N-L}(x_{n+L} - \bar x)(x_n - \bar x).
\]</div>
<p>Because we sum many positive terms, we expect to find a large positive value for <span class="math notranslate nohighlight">\(r_{xx}[0]\)</span>. And indeed, that’s what we find; let’s print the value of the autocovariance at lag 0:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac</span><span class="p">[</span><span class="n">lags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([0.50471724])
</pre></div>
</div>
</div>
</div>
<p>Let’s now consider shifting the EEG data by <strong>an integer multiple</strong> of the 60 Hz cycle. Let’s use a particular integer multiple of 2:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">);</span>       <span class="c1"># Plot the original</span>
<span class="n">L</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>                               <span class="c1"># Choose the lag,</span>
                                                <span class="c1"># ... and plot the shifted traces.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[[</span><span class="n">i</span> <span class="o">+</span> <span class="n">L</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> 
     <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="n">legend</span><span class="p">()</span>                                        <span class="c1"># Add a legend and informative title</span>
<span class="n">title</span><span class="p">(</span><span class="s2">&quot;Original time series data, and shifted by amount L</span><span class="se">\n</span><span class="s2">Autocovariance = </span><span class="si">{:.4}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">lags</span><span class="o">==</span><span class="n">L</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_54_0.png" src="_images/03_54_0.png" />
</div>
</div>
<p>Therefore, at this lag <span class="math notranslate nohighlight">\(L\)</span>, we again expect the summed product</p>
<div class="math notranslate nohighlight">
\[
  (x_{n+L} - \bar x)(x_n - \bar x)
\]</div>
<p>over all indices <span class="math notranslate nohighlight">\(n\)</span> to be large, and to find a large positive value for <span class="math notranslate nohighlight">\(r_{xx}[L]\)</span>. To see  that’s what we find let’s print the value of the autocovariance at lag 34:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac</span><span class="p">[</span><span class="n">where</span><span class="p">(</span><span class="n">lags</span> <span class="o">==</span> <span class="n">L</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([0.48702814])
</pre></div>
</div>
</div>
</div>
<p>Notice that this value is positive, and near the value of the autocorrelation at lag 0. In fact, we expect the autocovariance to be large and positive whenever the lag <span class="math notranslate nohighlight">\(L\)</span> is an integer multiple of the 60 Hz cycle (i.e., an integer multiple of 1/60 ≈ 0.0166 s); this is exactly what we find in the <a class="reference external" href="#fig:3-4a">plot of the autocovariance</a>.<span class="sup">fig<img src="imgs/3-4a.png"></span></p>
<p>Finally, let’s shift the EEG data by <strong>half</strong> of the 60 Hz cycle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">);</span>       <span class="c1"># Plot the original</span>
<span class="n">L</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>                             <span class="c1"># Choose the lag,</span>
                                                <span class="c1"># ... and plot the shifted traces.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">x</span><span class="p">[[</span><span class="n">i</span> <span class="o">+</span> <span class="n">L</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> 
     <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="n">legend</span><span class="p">()</span>                                        <span class="c1"># Add a legend and informative title</span>
<span class="n">title</span><span class="p">(</span><span class="s2">&quot;Original time series data, and shifted by amount L</span><span class="se">\n</span><span class="s2">Autocovariance = </span><span class="si">{:.4}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">lags</span><span class="o">==</span><span class="n">L</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_59_0.png" src="_images/03_59_0.png" />
</div>
</div>
<p>We observe a different type of relationship; at this lag, let’s call it <span class="math notranslate nohighlight">\(L^∗\)</span>, positive values in the unshifted EEG correspond to negative values in the shifted EEG. Therefore, most terms in the product</p>
<div class="math notranslate nohighlight">
\[
  (x_{n + L^*} - \bar x)(x_n - \bar x)
\]</div>
<p>are negative, and summing up these terms to compute the autocovariance we find a large <strong>negative</strong> value for <span class="math notranslate nohighlight">\(r_{xx}[L^*]\)</span>. To see that, let’s print the value of the autocovariance at lag 8:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac</span><span class="p">[</span><span class="n">lags</span> <span class="o">==</span> <span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([-0.49007471])
</pre></div>
</div>
</div>
</div>
<p>Finally, let’s plot the autocovariance again, highlighting the lags we investigated above, at different shifts in the 60 Hz cycle</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the autocovariance again, highlighting lags at 3 different shifts in the 60 Hz cycle</span>
<span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]</span>        <span class="c1"># Get the lags in a limited range</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="n">inds</span><span class="p">],</span> <span class="n">ac</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>                       <span class="c1"># ... and plot the autocovariance,</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>                                   <span class="c1"># Consider three specific lags</span>
<span class="n">plot</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">ac</span><span class="p">[[</span><span class="n">l</span> <span class="ow">in</span> <span class="n">L</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span> <span class="c1"># ... and highlight them</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag&#39;</span><span class="p">)</span>                                    <span class="c1"># Label the axes.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Autocovariance&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_63_0.png" src="_images/03_63_0.png" />
</div>
</div>
<p>The autocovariance is a useful tool for assessing the dependent structure in the EEG data. Visual inspection of the EEG reveals a specific type of dependent structure - a strong rhythmic component - in the data. This dependent structure is further characterized in the autocovariance, in which the dominant 60 Hz activity manifests as periodic peaks and troughs in the autocovariance. In the next section, we consider a second tool - the spectrum - for assessing dependent structure in time series data. As we’ll see, the autocovariance and spectrum are intimately related in a remarkable way.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="power-spectral-density"></a></p>
</div>
<div class="section" id="step-4-power-spectral-density-or-spectrum">
<h2>Step 4: Power spectral density, or spectrum<a class="headerlink" href="#step-4-power-spectral-density-or-spectrum" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;OAHpkZy6ZX8&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/OAHpkZy6ZX8"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>There are many techniques to assess rhythmic activity in the EEG data. Here, we compute the <em>power spectral density</em>, or simply the <em>spectrum</em>, of <span class="math notranslate nohighlight">\(x\)</span> using a well-established technique, the <a href="https://en.wikipedia.org/wiki/Fourier_transform" rel="external"><em>Fourier transform</em></a>. There are many subtleties associated with computing and interpreting the spectrum. We explore some of them here; in doing so, we build our intuition for spectral analysis and our ability to deal with future, unforeseen circumstances in other data we encounter in research.</p>
<div class="math-note">
<p>The <em>spectrum</em> of the data <span class="math notranslate nohighlight">\(x\)</span> is the magnitude squared of the Fourier transform of <span class="math notranslate nohighlight">\(x\)</span>. The spectrum indicates the amplitude of rhythmic activity in <span class="math notranslate nohighlight">\(x\)</span> as a function of frequency.</p>
<p>The <em>power spectral density</em> describes the extent to which sinusoids of a single frequency capture the structure of the data. To compute the power over any range of frequencies, we would integrate (or for discrete frequencies, sum) the spectrum over that frequency range.</p>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;iPUpMS79xgo&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/iPUpMS79xgo"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p><a id="spectrum"></a>
<strong>Computing the spectrum.</strong> We start by presenting all the formulas and code necessary to compute the spectrum of the data. Then throughout the rest of this notebook, we circle back and consider each step of the computation in detail.</p>
<p>We first need a formula for the discrete-time Fourier transform of the data x:<a id="eq:3.8"></a></p>
<div class="math notranslate nohighlight">
\[
  X_j = \sum_{n=1}^N x_n \exp(-2 \pi i f_j t_n).
\]</div>
<p>The Fourier transform computes the sum over all the time indices <span class="math notranslate nohighlight">\(t_n = \Delta\{1, 2, 3, ..., N\}\)</span> of the data <span class="math notranslate nohighlight">\(x_n\)</span> multiplied by sinusoids oscillating at a given frequency <span class="math notranslate nohighlight">\(f_j = j / T\)</span>, where <span class="math notranslate nohighlight">\(j = \{N/2 + 1, -N/2 + 2, ..., N/2 - 1, N/2\}\)</span>. The result is a new quantity <span class="math notranslate nohighlight">\(X_j\)</span>, the signal as a function of frequency <span class="math notranslate nohighlight">\(f_j\)</span> rather than time <span class="math notranslate nohighlight">\(t_n\)</span>. The spectrum is then <a id="eq:3.9"></a></p>
<div class="math notranslate nohighlight">
\[
  S_{xx, j} = \frac{2\Delta^2}{T}X_j X_j^*,
\]</div>
<p>which is the product of the Fourier transfrom of <span class="math notranslate nohighlight">\(x\)</span> with its complex conjugate (indicated by the superscript <span class="math notranslate nohighlight">\(*\)</span>), scaled by the sampling interval and the total duration of the recording. The term <span class="math notranslate nohighlight">\(2\Delta^2/T\)</span> is simply a numerical scaling. The units of the spectrum are, in this case, (<span class="math notranslate nohighlight">\(\mu\)</span>V)<span class="math notranslate nohighlight">\(^2/\)</span>Hz. Computing the spectrum in Python requires only a few lines of code:<a id="fig:3.6"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>                  <span class="c1"># Compute Fourier transform of x</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">xf</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">xf</span><span class="p">))</span> <span class="c1"># Compute spectrum</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">Sxx</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>             <span class="c1"># Ignore negative frequencies</span>

<span class="n">df</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">T</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>                        <span class="c1"># Determine frequency resolution</span>
<span class="n">fNQ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span>                        <span class="c1"># Determine Nyquist frequency</span>
<span class="n">faxis</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">fNQ</span><span class="p">,</span><span class="n">df</span><span class="p">)</span>                <span class="c1"># Construct frequency axis</span>

<span class="n">plot</span><span class="p">(</span><span class="n">faxis</span><span class="p">,</span> <span class="n">real</span><span class="p">(</span><span class="n">Sxx</span><span class="p">))</span>                  <span class="c1"># Plot spectrum vs frequency</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>                          <span class="c1"># Select frequency range</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>                <span class="c1"># Label the axes</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [$\mu V^2$/Hz]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_70_0.png" src="_images/03_70_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;kmHCCzAbMVI&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/kmHCCzAbMVI"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>That’s not so bad; the code to compute and display the spectrum fits in 13 lines (with spacing for aesthetics). Notice the large peak at 60 Hz. This peak is consistent with our visual inspection of the EEG data, in which we approximated a dominant rhythm at 60 Hz by counting the number of peaks that appeared in the voltage traces. So, our computation of the spectrum at least matches our initial expectation deduced from visual inspection of the data.</p>
<p>We’ve managed to compute and plot the spectrum, and our analysis results match our expectations. We could choose to stop here. But a danger persists: we’ve blindly entered Python code and achieved an expected result. What are the frequency resolution and Nyquist frequency mentioned in the comments of the code? Maybe this procedure is fraught with pitfalls, and we simply got lucky in this case? Does the spectrum provide additional information that was not immediately uncovered? How will we react and adapt when the spectrum results do not match our intuition? To answer these questions requires developing more intuition for the Fourier transform and spectrum.</p>
<p>In a <a class="reference external" href="#supplements">supplement to this chapter</a>, we examine equations for the Fourier transform <a href="#eq:3.8" class="thumb"><span><img src="imgs/eq3-8.png"></span></a> and spectrum <a href="#eq:3.9" class="thumb"><span><img src="imgs/eq3-9.png"></span></a> and the Python code for computing these quantities. In doing so, we explore some subtleties of this measure and strengthen our intuition for this measure’s behavior. Building this intuition is perhaps the most important part of dealing with unforeseen circumstances arising in your own data. If this is your first time thinking about the spectrum or Fourier transform, we recommend that you take a moment to read the supplement.</p>
<p><a id="dft"></a></p>
</div>
<div class="section" id="discrete-fourier-transform-in-python">
<h2>Discrete Fourier Transform in Python<a class="headerlink" href="#discrete-fourier-transform-in-python" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;noCOC69jvh8&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/noCOC69jvh8"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Computing the spectrum of a signal <span class="math notranslate nohighlight">\(x\)</span> in Python can be achieved in two simple steps. The first step is to compute the Fourier transform of <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">EEG</span>
<span class="n">xf</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>We subtract the mean from <code class="docutils literal notranslate"><span class="pre">x</span></code> before computing the Fourier transform. This is not necessary but often useful. For these neural data, we’re not interested in the very slow (0 Hz) activity; instead, we’re interested in rhythmic activity. By subtracting the mean, we eliminate this low-frequency activity from the subsequent analysis.</p>
<p>The second step is to compute the spectrum, the Fourier transform of <span class="math notranslate nohighlight">\(x\)</span> multiplied by its complex conjugate:<a id="fig:3.10"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sxx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="n">xf</span> <span class="o">*</span> <span class="n">xf</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
<span class="n">plot</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Indices&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [$\mu V^2$/Hz]&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_78_0.png" src="_images/03_78_0.png" />
</div>
</div>
<p>Upon examining the horizontal axis in this plot, we find it corresponds to the indices of <code class="docutils literal notranslate"><span class="pre">x</span></code>, beginning at index 0 and ending at index <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1000</span></code>. To convert the x-axis from indices to frequencies, we need to define two new quantities:</p>
<ul class="simple">
<li><p>the <strong>frequency resolution</strong>, <span class="math notranslate nohighlight">\(df = \frac{1}{T}\)</span>, or the reciprocal of the total recording duration;</p></li>
<li><p>the <strong>Nyquist frequency</strong>, <span class="math notranslate nohighlight">\(f_{NQ} = \frac{f_0}{2} = \frac{1}{2\Delta}\)</span>, or half of the sampling frequency <span class="math notranslate nohighlight">\(f_0 = \frac{1}{\Delta}\)</span>.</p></li>
</ul>
<p>For the clinical EEG data considered here, the total recording duration is 2 s (<span class="math notranslate nohighlight">\(T = 2\)</span> s), so the frequency resolution</p>
<div class="math notranslate nohighlight">
\[
  df = 1 / (2\ s) = 0.5\ Hz.
\]</div>
<p>The sampling frequency <span class="math notranslate nohighlight">\(f_0\)</span> is 1000 Hz, so</p>
<div class="math notranslate nohighlight">
\[
  f_{NQ} = 1000 / 2\ Hz = 500\ Hz.
\]</div>
<p>There’s much more to say about both quantities, but for now let’s simply use both quantities to consider how Python relates the indices and frequencies of the vector <code class="docutils literal notranslate"><span class="pre">Sxx</span></code>.</p>
<div class="python-note">
<p>When we used the <code class="docutils literal notranslate"><span class="pre">rfft</span></code> function we utilized a useful property of the Fourier transform. If instead of using <code class="docutils literal notranslate"><span class="pre">rfft</span></code> we had used <code class="docutils literal notranslate"><span class="pre">fft</span></code>, we would see that the vector <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> is twice as long because the Fourier transform also calculates the spectrum for the negative frequencies. However, when a signal is real (i.e., the signal has zero imaginary component), the negative frequencies in the spectrum are redundant. So, the power we observe at frequency <span class="math notranslate nohighlight">\(f\)</span> is identical to the power we observe at frequency <span class="math notranslate nohighlight">\(-f\)</span>. For this reason, we can safely ignore the negative frequencies; these frequencies provide no additional information. Because the EEG data are real, we conclude that the negative frequencies in the variable <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> are redundant and can be ignored. As a specific example, the value of <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> at index <span class="math notranslate nohighlight">\(j = 2\)</span> is the same as the value of <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> at index <span class="math notranslate nohighlight">\(j = 2N - 2\)</span>; these indices correspond to frequencies <span class="math notranslate nohighlight">\(2df\)</span> and  <span class="math notranslate nohighlight">\(-2df\)</span>, respectively. We therefore need only plot the variable <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> for the positive frequencies, more specifically, from index <code class="docutils literal notranslate"><span class="pre">0</span></code> to index <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</div><p>Given the total duration of the recording (<span class="math notranslate nohighlight">\(T\)</span>) and the sampling frequency (<span class="math notranslate nohighlight">\(f_0\)</span>) for the data, we can define the frequency axis for the spectrum <code class="docutils literal notranslate"><span class="pre">Sxx</span></code>. Now, to compute and plot the spectrum, we again utilize some code introduced earlier:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">T</span> <span class="o">*</span> <span class="p">(</span> <span class="n">xf</span> <span class="o">*</span> <span class="n">xf</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>
<span class="n">df</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">T</span>
<span class="n">fNQ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">faxis</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Sxx</span><span class="p">))</span> <span class="o">*</span> <span class="n">df</span>
<span class="n">plot</span><span class="p">(</span><span class="n">faxis</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [$\mu V^2$/Hz]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_82_0.png" src="_images/03_82_0.png" />
</div>
</div>
<p>In the next two sections, we focus on interpreting and adjusting the quantities <span class="math notranslate nohighlight">\(df\)</span> and <span class="math notranslate nohighlight">\(f_{NQ}\)</span>. Doing so is critical to developing a further intuition for the spectrum.</p>
<p><a id="nyquist-frequency"></a></p>
</div>
<div class="section" id="the-nyquist-frequency">
<h2>The Nyquist frequency<a class="headerlink" href="#the-nyquist-frequency" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;sgYkOkrlQ_E&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/sgYkOkrlQ_E"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>The formula for the Nyquist frequency is <a id="eq:3.13"></a></p>
<div class="math notranslate nohighlight">
\[
  f_{NQ} = \frac{f_0}{2}.
\]</div>
<p>The Nyquist frequency is the highest frequency we can possibly hope to observe in the data. To illustrate this, let’s consider a true EEG signal that consists of a very simple time series—a pure sinusoid that oscillates at some frequency <span class="math notranslate nohighlight">\(f_s\)</span>. Of course, we never observe the true signal. Instead, we observe a sampling of this signal, which depends on the sampling interval <span class="math notranslate nohighlight">\(\Delta\)</span>. We consider three cases for different values of <span class="math notranslate nohighlight">\(\Delta\)</span>. In the first case, we purchase a very expensive piece of equipment that can sample the true signal at a high rate, <span class="math notranslate nohighlight">\(f_0 \gg f_s\)</span>. In this case, we cover the true brain signal with many samples and given these samples, we can accurately reconstruct the underlying data.</p>
<p><a id="fig:3.11top"><img src="imgs/3-11top.png" title="A sinusoid oscillating below the Nyquist frequency. When the sampling rate is high enough, the sampled data provide a good approximation to the true data. Here, the sampling frequency is 8 times the oscillation frequency (i.e. the sinusoid is sampled eight times in each oscillation of the function)." alt="Sampling a sinusoid at a high rate."></a></p>
<p>Now, consider the case in which we purchase a cheaper piece of equipment that samples at a maximum rate equivalent to twice the frequency of the pure sinusoid: <span class="math notranslate nohighlight">\(f_0 = 2f_s\)</span>. In this case, we might collect sufficient samples to cover the underlying signal and approximate the oscillation frequency; if the first sample resides on a peak of the sinusoid, the next sample on a trough, and so on.</p>
<p><a id="fig:3.11mid"><img src="imgs/3-11mid.png" title="A sinusoid oscillating at the Nyquist frequency. In this case we collect two samples per cycle of the underlying true signal." alt="Sampling a sinusoid at double the oscillation frequency."></a></p>
<p>In this case, we collect two samples per cycle of the underlying true signal. Given only these sample points, we can connect the dots and still approximate the frequency fo the true underlying sinusoid.</p>
<div class="question">
<p><strong>Q.</strong> For the sampling rate <span class="math notranslate nohighlight">\(f_0 = 2f_s\)</span>, consider the case in which the first sample occurs on a zero crossing of the sinusoid. At what point does the next sample occur? and the next sample? If you connect the dots in this case, what do you find?</p>
</div><p>Finally, consider the case where our equipment records at a sampling rate less than the frequency of the pure sinusoid signal: <span class="math notranslate nohighlight">\(f_0 &lt; 2 f_s\)</span>.</p>
<p><a id="fig:3.11bot"><img src="imgs/3-11bot.png" title="A sinusoid oscillating above the Nyquist frequency. When the sampling rate is too low, the true high-frequency signal appears as a low-frequency oscillation." alt="Sampling a sinusoid at less than double the oscillation frequency."></a></p>
<p>Assuming the first sample occurs at a peak of the sinusoid, the next sample occurs not at a trough (that would correspond to a sampling rate <span class="math notranslate nohighlight">\(f_0 = 2f_s\)</span>) but instead just after the trough. Connecting the samples with lines, in this case, produces something horrifying, an oscillation occurring at a different, lower frequency. Notice what has happened in this case. Sampling the sinusoid at too low a frequency (i.e., at a frequency less than twice the signal’s frequency <span class="math notranslate nohighlight">\(f_0 &lt; 2f_s\)</span>) causes this signal to manifest at a low-frequency upon sampling. This phenomenon—a high-frequency signal appearing as a low-frequency signal upon sampling—is known as <em>aliasing</em>. Once a signal has been aliased, it’s impossible to distinguish from true signals oscillating at low frequencies.</p>
<div class="math-note">
<p>To avoid aliasing, sample data at sufficiently high rates.</p>
</div><p>Typically, to prevent aliasing, recorded data are first analog-filtered before the digital sampling occurs. The analog filtering guarantees that activity at frequencies exceeding a threshold value (<span class="math notranslate nohighlight">\(f_c\)</span>, say) are dramatically reduced. The sampling rate can then be chosen to exceed this threshold value by at least a factor of 2 (i.e., <span class="math notranslate nohighlight">\(f_0 &gt; 2f_c\)</span>). We note that in this case the EEG data were first analog-filtered at 200 Hz before digital sampling occurred at 1000 Hz. So, for our EEG data, aliasing is not a concern.</p>
<p><a id="frequency-resolution"></a></p>
</div>
<div class="section" id="the-frequency-resolution">
<h2>The frequency resolution<a class="headerlink" href="#the-frequency-resolution" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;bZsj_gcGoSo&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/bZsj_gcGoSo"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>The frequency resolution is defined as</p>
<div class="math notranslate nohighlight">
\[
  df = \frac{1}{T}
\]</div>
<p>where <span class="math notranslate nohighlight">\(T\)</span> is the total duration of the recording. For the EEG data used in this notebook, <span class="math notranslate nohighlight">\(T = 2\)</span> s, so the frequency resolution is <span class="math notranslate nohighlight">\(df = 1/(2\ \mbox s) = 0.5\)</span> Hz.</p>
<div class="question">
<p><strong>Q.</strong> How do we improve the frequency resolution?</p>
<p><strong>A.</strong> There’s only one way to do it: increase <span class="math notranslate nohighlight">\(T\)</span>. That is, record more data. For example, if we demand a frequency resolution of 0.2 Hz, how much data must we record? We can rearrange the equation to solve for <span class="math notranslate nohighlight">\(T\)</span>,</p>
<div class="math notranslate nohighlight">
\[
  T = \frac{1}{df} = \frac{1}{0.2\mbox{ Hz}} = 5\mbox{ s}
\]</div>
<p>So, record 5 s of data to obtain a frequency resolution of 0.2 Hz.</p>
</div><div class="question">
<p><strong>Q.</strong> We estimated the spectrum in the preceding code. As we record more and more data, does the estimate of the spectrum improve?</p>
<p><strong>A.</strong> Intuitively, you might answer yes. As we collect more and more data, we usually expect our estimate of a quantity (e.g., the mean or the standard deviation) to improve. However, that is not the case for the spectrum. As we collect more and more data, we acquire more and more points along the frequency axis (i.e., <span class="math notranslate nohighlight">\(df\)</span> becomes smaller). However, our estimate of the power at each frequency does not improve (<a href="https://doi.org/10.1017/CBO9780511622762" rel="external">Percival &amp; Walden, 1993</a>).</p>
</div><p>To gain some intuition for the frequency resolution formula, consider the case in which we collect <span class="math notranslate nohighlight">\(T\)</span> seconds of data. If the sampling interval is <span class="math notranslate nohighlight">\(\Delta\)</span>, then we collect <span class="math notranslate nohighlight">\(N = T/\Delta\)</span> data points; for example, for the EEG data of interest here, we collect <span class="math notranslate nohighlight">\(N = 2000\)</span> data points. We know that the number of observations in the data equals the number of frequencies in the spectrum (where we now include negative frequencies); both the data vector <code class="docutils literal notranslate"><span class="pre">x</span></code> and the spectrum vector <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> have length <span class="math notranslate nohighlight">\(N\)</span>. We also know that the maximum observable frequency in the spectrum, the Nyquist frequency, is fixed no matter how much data we collect. Recall that the Nyquist frequency depends only on the sampling interval: <span class="math notranslate nohighlight">\(f_{NQ} = 1/(2\Delta)\)</span>. Now, consider the case in which we increase <span class="math notranslate nohighlight">\(T\)</span>, or equivalently, increase <span class="math notranslate nohighlight">\(N\)</span>. As we collect more and more data, the maximum frequency remains fixed at the Nyquist frequency, while the length of the spectrum vector increases. We therefore need to fit more and more frequency values between 0 Hz and the Nyquist frequency as <span class="math notranslate nohighlight">\(N\)</span> increases.</p>
<p><a id="fig:3.12"><img src="imgs/3-12.png" alt="Cartoon representation of the relation between data and frequency resolution."></a></p>
<p>Above we plot a cartoon representation of the relation between data and frequency resolution. Data (left) consist of different numbers of samples (<span class="math notranslate nohighlight">\(N\)</span>). As <span class="math notranslate nohighlight">\(N\)</span> increases, the number of values on the frequency axis increases (right), the maximal frequency <span class="math notranslate nohighlight">\((f_{NQ})\)</span> remains fixed, and the frequency resolution (<span class="math notranslate nohighlight">\(df\)</span>) decreases. Only non-negative frequencies are shown.
This observation provides some intuition for the relation between the amount of data recorded (<span class="math notranslate nohighlight">\(T\)</span> or <span class="math notranslate nohighlight">\(N\)</span>) and the frequency resolution (<span class="math notranslate nohighlight">\(df\)</span>).</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="decibel-scaling"></a></p>
</div>
<div class="section" id="step-5-decibel-scaling">
<h2>Step 5: Decibel scaling<a class="headerlink" href="#step-5-decibel-scaling" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;SuDJha5LNL0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/SuDJha5LNL0"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>Let’s now return to the <a class="reference external" href="#fig:3-6">spectrum of the EEG data</a>.
<span class="sup">fig<img src="imgs/3-6.png"></span>
We see that the spectrum is dominated by a single peak at 60 Hz. Other, weaker rhythmic activity may occur in the data, but these features remain hidden from visual inspection because of the large 60 Hz peak; informally, we might state that the 60 Hz peak saturates the vertical scale. One technique to emphasize lower-amplitude rhythms hidden by large-amplitude oscillations is to change the scale of the spectrum to <strong>decibels</strong>. The decibel is a logarithmic scale and easily computed as follows:
<a id="fig:3.13a"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">faxis</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)))</span>  <span class="c1"># Plot the spectrum in decibels.</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>                           <span class="c1"># Select the frequency range.</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>                           <span class="c1"># Select the decibel range.</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>                 <span class="c1"># Label the axes.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [dB]&#39;</span><span class="p">)</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/3-13a&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_100_0.png" src="_images/03_100_0.png" />
</div>
</div>
<p>To change to the decibel scale, we first divide the spectrum by the maximum value observed and then take the logarithm base 10 of this ratio and multiply the result by 10. The 60 Hz rhythm is still dominant and exhibits the most power.</p>
<div class="question">
<p><strong>Q.</strong> For this example, what is the value in decibels at 60 Hz?</p>
<p><strong>A.</strong> Through our previous analysis, we know that the maximum value in the spectrum occurs at 60 Hz. By dividing the original spectrum by this maximum, we scale the spectrum at 60 Hz to a value of 1. The logarithm of 1 is 0, so we find a value of 0 at 60 Hz. Note that all other values are now smaller than 1 and therefore negative on the decibel scale.</p>
</div><div class="math-note">
<p>Different conventions exist to define the decibel scale. Here we first divide by the maximum before computing the logarithm. Be sure to verify how the spectrum is scaled (if at all) to interpret the decibel axis.</p>
</div><p>The decibel scale reveals new structure in the spectrum. In particular, two peaks have emerged at frequencies 5–15 Hz. These peaks are much weaker than the 60 Hz signal; both peaks are approximately 30 dB below the maximum at 60 Hz, or equivalently, three <em>orders of magnitude</em> weaker. Because these peaks are so small relative to the 60 Hz signal, neither was apparent in the original plot of the spectrum.</p>
<p>To further emphasize the low-frequency structure of the spectrum, we may also convert the frequency axis to a logarithmic scale:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">semilogx</span><span class="p">(</span><span class="n">faxis</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)))</span>  <span class="c1"># Log-log scale</span>
<span class="n">xlim</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>                              <span class="c1"># Select frequency range</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>                               <span class="c1"># ... and the decibel range.</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>                     <span class="c1"># Label the axes.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [dB]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_104_0.png" src="_images/03_104_0.png" />
</div>
</div>
<p>Notice the change in the first line to use the <code class="docutils literal notranslate"><span class="pre">semilogx</span></code> function. By using the logarithmic scale to stretch the low-frequency part of the horizontal axis, the two low-frequency peaks become more apparent. The changes compared to the original spectrum are purely cosmetic. However, these cosmetic changes have proved extremely useful. The two lower-frequency peaks were originally hidden from us, both in visual inspection of the raw data and in the original plot of the spectrum. In those cases, the large-amplitude 60 Hz activity masked the smaller-amplitude (three orders of magnitude smaller) rhythms.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="the-spectrogram"></a></p>
</div>
<div class="section" id="step-6-the-spectrogram">
<h2>Step 6: The spectrogram<a class="headerlink" href="#step-6-the-spectrogram" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;XYy4NEr3VUs&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/XYy4NEr3VUs"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>The spectrum <a class="reference external" href="#fig:3.13a">plotted using the decibel scale</a><span class="sup">fig<img src="imgs/3-13a.png"></span> suggests that three rhythms appear in the EEG signal: 60 Hz, approximately 11 Hz, and approximately 6 Hz. Given only these results, we may reasonably conclude that these three rhythms appear simultaneously throughout the entire 2 s of the EEG recording. That is an assumption we make in computing the spectrum of the entire 2 s interval. To further test this assumption in the EEG data, we compute a final quantity: the <em>spectrogram</em>. The idea of the spectrogram is to break up the time series into smaller intervals of data and then compute the spectrum in each interval. These intervals can be quite small and can even overlap. The result is the spectrum as a function of frequency and time.</p>
<div class="question">
<p><strong>Q.</strong> Consider the 2 s of EEG data. If we break up these data into smaller intervals of duration 1 s, what is the resulting frequency resolution of each interval? What is the Nyquist frequency of each interval?</p>
</div><p>To compute and display the spectrogram in Python, we use the (aptly named) function <code class="docutils literal notranslate"><span class="pre">spectrogram</span></code> from the <code class="docutils literal notranslate"><span class="pre">scipy</span></code> module:<a id="fig:3.14"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Fs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt</span>               <span class="c1"># Define the sampling frequency,</span>
<span class="n">interval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span>        <span class="c1"># ... the interval size,</span>
<span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Fs</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">)</span>  <span class="c1"># ... and the overlap intervals</span>

                          <span class="c1"># Compute the spectrogram</span>
<span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span>
    <span class="n">EEG</span><span class="p">,</span>                  <span class="c1"># Provide the signal,</span>
    <span class="n">fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>                <span class="c1"># ... the sampling frequency,</span>
    <span class="n">nperseg</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>     <span class="c1"># ... the length of a segment,</span>
    <span class="n">noverlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>     <span class="c1"># ... the number of samples to overlap,</span>
<span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span><span class="p">),</span>
               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span><span class="c1"># Plot the result</span>
<span class="n">colorbar</span><span class="p">()</span>                <span class="c1"># ... with a color bar,</span>
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">70</span><span class="p">])</span>             <span class="c1"># ... set the frequency range,</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>        <span class="c1"># ... and label the axes</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/3-14&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_111_0.png" src="_images/03_111_0.png" />
</div>
</div>
<p>We supplied four arguments to the <code class="docutils literal notranslate"><span class="pre">spectrogram</span></code> function. Briefly, these arguments specify the data, the sampling frequency, the interval size (specified in indices and here set to 1 s), and the overlap between intervals (here set to 95%). More information about these options can be found in the documentation (<code class="docutils literal notranslate"><span class="pre">signal.spectrogram?</span></code>). Notice that we used <code class="docutils literal notranslate"><span class="pre">int</span></code> to enforce integer values for three of these inputs.</p>
<div class="python-note">
<p>Note that in computing the spectrogram, we did not subtract the mean as we have done in the past. This is because the <code class="docutils literal notranslate"><span class="pre">spectrogram</span></code> function defaults to this behavior.</p>
</div><div class="question">    
<p><strong>Q.</strong> Consider the spectrogram above. What aspects of the spectrogram are consistent with our previous results? What aspects are new? Consider, in particular, the low-frequency rhythms and the conclusions deduced from this figure compared to the plot of the spectrum.<span class="sup">fig<img src="imgs/3-13a.png"></span></p>
<p><strong>A.</strong> The spectrogram displays the spectrum (in decibels) as a function of frequency (vertical axis) and time (horizontal axis). Values on the time axis indicate the center times of each 1 s window (e.g., 0.5 s corresponds to times [0, 1] s in the data). Intervals of high (low) values correspond to warm (cool) colors. Visual inspection immediately provides new insights into the observed EEG rhythms. First, we observe a band of high power at 60 Hz that persists for all time (yellow horizontal line in the plot of the spectrogram). This corresponds to the 60 Hz line noise present for the entire duration of the recording. Second, we observe intervals of increased power near 11 Hz and 6 Hz. Unlike the 60 Hz signal, the two low-frequency rhythms do not persist for the entire 2 s recording (as we may have incorrectly concluded from examination of the spectrum alone. Instead, one weak rhythm (near 6 Hz) appears for the first half of the recording, while another weak rhythm (near 11 Hz) appears for the second half of the recording. Visualization via the spectrogram of how the rhythmic activity changes in time allows this important conclusion.</p>
</div><p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="summary"></a></p>
</div>
</div>
<div class="section" id="summary">
<h1>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;jdceZRY_PDA&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/jdceZRY_PDA"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>In this notebook, we analyzed 2 s of EEG data. We started with visual inspection of the <a class="reference external" href="#fig:3.1">EEG time series</a>.<span class="sup">fig<img src="imgs/3-1.png"></span> This is always the best place to start when analyzing new data and provides initial important intuition for the time series. Through the initial visual inspection, we concluded that rhythmic activity appeared and was dominated by a 60 Hz oscillation. Then, to characterize further the rhythmic activity, we computed two related quantities: the autocovariance and the spectrum. We found that rhythmic activity appeared in the autocovariance of the data. We then considered the spectrum. To do so, we first introduced the notion of the Fourier transform and discussed in detail how to compute the spectrum in Python. We also defined two fundamental quantities—the frequency resolution and the Nyquist frequency—and explored how to manipulate these quantities. (We recommend you commit both quantities to memory. For every spectral analysis you encounter, ask: What is the frequency resolution? What is the Nyquist frequency?). We then considered how <a class="reference external" href="#fig:3.13a">logarithmic scales</a>  can be used to emphasize features of the spectrum.<span class="sup">fig<img src="imgs/3-13a.png"></span> And, we examined how the <a class="reference external" href="#fig:3.14">spectrogram</a> provides insight into spectral features that change in time.<span class="sup">fig<img src="imgs/3-14.png"></span> We concluded that the EEG data are dominated by 60 Hz activity throughout the 2 s interval, and that weaker low-frequency activity emerges during two intervals: a 6 Hz rhythm from 0 s to 1 s, and an 11 Hz rhythm from 1 s to 2 s.</p>
<p>In this notebook, we only touched the surface of spectral analysis; many details and issues exist for further exploration. In future notebooks, we will discuss the issues of windowing and zero padding. For those interested in exploring further, see <a href="https://doi.org/10.1017/CBO9780511622762" rel="external">Percival &amp; Walden, 1998</a> and <a href="https://buprimo.hosted.exlibrisgroup.com/primo-explore/fulldisplay?docid=ALMA_BOSU121668583370001161&context=L&vid=BU&search_scope=default_scope&tab=default_tab&lang=en_US" rel="external">Priestley, 1981</a>.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="donate"></a></p>
<div class="section" id="donate">
<h2>Donate<a class="headerlink" href="#donate" title="Permalink to this headline">¶</a></h2>
<p>If you enjoy Case-Studies-Python, and would like to share your enjoyment with us, sponsor our coffee consuption <a href="https://www.paypal.com/donate/?hosted_button_id=DL8P5ZGS9962U">here</a>.</p>
<hr class="docutils" />
<p><a id="supplements"></a></p>
</div>
</div>
<div class="section" id="supplements">
<h1>Supplements<a class="headerlink" href="#supplements" title="Permalink to this headline">¶</a></h1>
<p><a id="supplement-acv"></a></p>
<div class="section" id="biased-versus-unbiased-autocovariance">
<h2>Biased versus unbiased autocovariance<a class="headerlink" href="#biased-versus-unbiased-autocovariance" title="Permalink to this headline">¶</a></h2>
<p>Autocovariance is defined by the equation</p>
<p><a id="eq:3.3"></a>
<span class="math notranslate nohighlight">\($
  r_{xx}[L] = \frac{1}{N}\sum_{n=1}^{N-L}(x_{n+L} - \bar x)(x_n - \bar x).
$\)</span></p>
<p>This is a biased estimate of the true autocovariance. To compute an <em>unbiased</em> measure of the autocovariance we replace the <span class="math notranslate nohighlight">\(1/N\)</span> term with <span class="math notranslate nohighlight">\(1/(N-L)\)</span>.</p>
<div class="math notranslate nohighlight">
\[
  r^*_{xx}[L] = \frac{1}{N - L}\sum_{n=1}^{N-L}(x_{n+L} - \bar x)(x_n - \bar x).
\]</div>
<p>To examine the difference in the biased versus the unbiased autocovariance, let’s compute both for the EEG data over a broad interval of lags.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/EEG-1.mat&#39;</span><span class="p">)</span>      <span class="c1"># Load the EEG data.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>               <span class="c1"># Extract the EEG variable,</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>                          <span class="c1"># ... and the t variable.</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                                <span class="c1"># Get the total number of data points,</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                          <span class="c1"># ... and the sampling interval.</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lags</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>                  <span class="c1"># Compute the lags</span>
                                          <span class="c1"># Calculate non-normalized autocovariance</span>
<span class="n">ac</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>  
<span class="n">ac_b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">ac</span>                         <span class="c1"># Calculate biased autocovariance</span>
<span class="n">ac_u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lags</span><span class="p">))</span> <span class="o">*</span> <span class="n">ac</span>           <span class="c1"># ... and unbiased autocovariance</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">()</span>                      <span class="c1"># Plot the result and save the figure for later use</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ac_u</span><span class="p">)</span>                  <span class="c1"># Plot the unbiased autocovariance,</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ac_b</span><span class="p">)</span>                  <span class="c1"># ... and the biased,</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Lag [s]&#39;</span><span class="p">)</span>                         <span class="c1"># ... with axes labeled</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Autocovariance&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_125_0.png" src="_images/03_125_0.png" />
</div>
</div>
<p>We see the similarities and differences between these two estimates. At small lags (near 0 s), the biased and unbiased estimates of the autocovariance are similar. In this case, <span class="math notranslate nohighlight">\(L\)</span> is small, so the factor 1/(N − L) in the unbiased estimate is similar to the factor of 1/N in the biased estimate. At large lags (away from 0 s), the biased and unbiased estimates of the autocovariance are quite different. Notice that, as L approaches ±2 s, the biased estimate (orange curve) approaches zero.</p>
<p>Compare this observation to the <em>unbiased</em> estimate of the autocovariance. In this example, we see that the unbiased estimate of the autocovariance remains large even as L approaches ± 2 (blue curve).</p>
<div class="question">
<p><strong>Q.</strong> Why does the biased estimate of the autocovariance approach 0 at large lags?</p>
<p><strong>A.</strong> For concreteness, let’s consider the case when <span class="math notranslate nohighlight">\(L = N - 2\)</span>. In this case, <span class="math notranslate nohighlight">\(L\)</span> is large, and nearly equal to the number of points in the data (<span class="math notranslate nohighlight">\(N\)</span>). When <span class="math notranslate nohighlight">\(L\)</span> is large, we shift the time series <span class="math notranslate nohighlight">\(x\)</span> so that only a subset of indices overlap; the following is a cartoon representation of the <span class="math notranslate nohighlight">\(L = 2\)</span> case:
<img alt="cartoon representation f L=2 autocovariance" src="_images/3-3d.png" />
Now consider the extension to <span class="math notranslate nohighlight">\(L=N-2\)</span>. Because we only compute the product</p>
<div class="math notranslate nohighlight">
\[
  (x_{n+L} - \bar x)(x_n - \bar x)
\]</div>
<p>for the overlapping indices of <span class="math notranslate nohighlight">\(x_n\)</span> and <span class="math notranslate nohighlight">\(x_{n+L}\)</span>, we only include two terms in the  summation <a href="#eq:3.3" class="thumb"><span><img src="imgs/eq3-3.png"></span></a> The sum of these two terms is then divided by <span class="math notranslate nohighlight">\(N\)</span>, which results in a small number that approaches zero as L approaches N.</p>
</div><div class="question">
<p><strong>Q.</strong> Why does the unbiased estimate of the autocovariance remain large at large lags?</p>
<p><strong>A.</strong> As in the biased case, let’s again consider <span class="math notranslate nohighlight">\(L = N-2\)</span>. In this case, <span class="math notranslate nohighlight">\(L\)</span> is large, and we shift the time series <span class="math notranslate nohighlight">\(x\)</span> so that only a subset of indices overlap. Therefore, the product</p>
<div class="math notranslate nohighlight">
\[
  (x_{n+L} - \bar x)(x_n - \bar x)
\]</div>
<p>again only includes two terms in the autocovariance summation. However, in the unbiased case, the sum of these terms is divided by</p>
<div class="math notranslate nohighlight">
\[
  N - L = N - (N - 2) = 2
\]</div>
<p>Notice that as <span class="math notranslate nohighlight">\(L\)</span> approaches <span class="math notranslate nohighlight">\(N\)</span>, the term <span class="math notranslate nohighlight">\(N - L\)</span> approaches zero. In this case, we find a “balance” between the summation of two terms then a division by the number of terms in the sum (in this example, division by 2). This balance allows the unbiased estimate of the autocovariance to remain large as <span class="math notranslate nohighlight">\(L\)</span> approaches <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>Careful inspection of the blue curve reveals another feature of the biased estimate; the estimated values at large lags become more variable (look carefully at lags near ±1.75 s and beyond).</p>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.75</span><span class="p">,</span> <span class="mf">1.75</span><span class="p">]]</span>
<span class="n">fig</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_129_0.png" src="_images/03_129_0.png" />
</div>
</div>
<div class="math-note">
<p>Increased variability at large lags occurs because, as <span class="math notranslate nohighlight">\(L\)</span> approaches <span class="math notranslate nohighlight">\(N\)</span>, we have less data to compare in the assessment of the autocovariance. Notice that, when <span class="math notranslate nohighlight">\(L = N − 1\)</span>, the estimate of the autocovariance utilizes only two data points from <span class="math notranslate nohighlight">\(x\)</span> (i.e., the product consists only of one term: <span class="math notranslate nohighlight">\((x_N - \bar x)(x_1 - \bar x)\)</span>). We do not expect a reliable assessment of associations in the data with so few data points to compare.</p>
</div><p>With those observations, should we use the biased or unbiased estimator of the autocovariance? Statisticians typically prefer the biased estimator for a variety of reasons [<a href="https://doi.org/10.1017/CBO9780511622762" rel="external">Percival &amp; Walden, 1998</a>]. First, for many stationary processes, the mean squared error of the biased estimator is smaller than that of the unbiased estimator. The mean squared error depends on both the variance and bias of the estimator:</p>
<div class="math notranslate nohighlight">
\[
  \mbox{mean squared error} = \mbox{variance + (bias)}^2.
\]</div>
<p>Although the biased estimator is “biased”, the variability of the unbiased estimator is more harmful. We saw a hint of this increased variability in the unbiased estimator at large lags. To make this observation more explicit, let’s consider the lag <span class="math notranslate nohighlight">\(L = N - 1\)</span>, and compute the expression for the <a class="reference external" href="#eq:3.3">biased estimator</a><span class="sup">eq<img src="imgs/eq3-3.png"></span>,</p>
<p title="Variance of the biased estimator with lag N-1">
<p>\begin{eqnarray}
r_{xx}[N-1] &amp;=&amp; \frac{1}{N} \sum_{n = 1}^{N - (N - 1)} (x_{n + (N - 1)} - \bar x)(x_n - \bar x),\
&amp;=&amp;\frac{1}{N}\sum_{n=1}^1(x_{n+(N-1)} - \bar x)(x_n - \bar x), \
&amp;=&amp;\frac{1}{N}(x_{N} - \bar x)(x_1 - \bar x).
\end{eqnarray}</p>
</p>
<p>The expression for the <a class="reference external" href="#eq:3.3">unbiased estimator</a><span class="sup">eq<img src="imgs/eq3-4.png"></span> becomes,</p>
<p title="Variance of the unbiased estimator with lag N-1">
<p>\begin{eqnarray}
r_{xx}^*[N-1] &amp;=&amp; \frac{1}{N - (N - 1)}\sum_{n=1}^{N - (N-1)}(x_{n+N-1} - \bar x)(x_n - \bar x), \
&amp;=&amp; \sum_{n=1}^1(x_{n+N-1} - \bar x)(x_n - \bar x), \
&amp;=&amp; (x_{N} - \bar x)(x_1 - \bar x), \
\end{eqnarray}</p>
</p><p>These two expressions reveal that, at a large lag <span class="math notranslate nohighlight">\(L = N − 1\)</span>, the variance of the unbiased estimator is <span class="math notranslate nohighlight">\(N^2\)</span> times the variance of the biased estimator. The dramatic increase in variance of the unbiased estimator leads to unreliable estimates of the autocovariance at large lags. Also, we note that the biased estimator behaves “nicely” as <span class="math notranslate nohighlight">\(L\)</span> increases to <span class="math notranslate nohighlight">\(N\)</span>; we see from the expression for the biased estimator that <span class="math notranslate nohighlight">\(r_{xx}[N − 1]\)</span> approaches 0 when <span class="math notranslate nohighlight">\(N\)</span> is large. This is arguably the behavior we want; we have few data points to compare at large lags, and therefore an unreliable estimate of the autocovariance, so we’re better off disregarding these values. For these reasons, we’ll use the biased estimator; in this estimate, autocovariance values at large lags - which utilize less data and are typically noisier - are reduced.</p>
<p>We note that, for the EEG data of interest here, the unbiased estimator outperforms the biased estimator. For these data, which are dominated by a 60 Hz rhythm, there is significant autocovariance even at long lags. In this case, the biased estimator leads to an interpretation of decreasing autocovariance, even though that is not true. However, for most brain signal (not saturated by 60 Hz line noise), we expect the autocovariance to decrease in time.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
<hr class="docutils" />
<p><a id=supplement-psd></a></p>
</div>
<div class="section" id="intuition-behind-the-power-spectral-density">
<h2>Intuition behind the power spectral density<a class="headerlink" href="#intuition-behind-the-power-spectral-density" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="#fourier-transform">The Fourier transform</a></p></li>
<li><p><a class="reference external" href="#autocovariance">Relation to autocovariance</a></p></li>
<li><p><a class="reference external" href="#multiple-linear-regression">Relation to multiple linear regression</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tools for this notebook</span>
<span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">df</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span>
</pre></div>
</div>
</div>
</div>
<p>The main component of this notebook discusses the analysis of rhythmic activity. One important component of this analysis is the power spectral density. In this supplement, we examine equation for the Fourier transform</p>
<div class="math notranslate nohighlight">
\[
  X_j = \sum_{n=1}^{N}x_n \exp(-2\pi i f_j t_n).
\]</div>
<p>and the equation for the spectrum</p>
<div class="math notranslate nohighlight">
\[
  S_{xx, j} = \frac{2\Delta^2}{T}X_j X_j^*,
\]</div>
<p>and the associated Python code. In doing so, we explore some subtleties of this measure and strengthen our intuition for this measure’s behavior. Building this intuition is perhaps the most important part of dealing with unforeseen circumstances arising in your own data.</p>
<p><a id="fourier-transform"></a></p>
<div class="section" id="what-is-the-fourier-transform-actually-doing">
<h3>What is the Fourier transform actually doing?<a class="headerlink" href="#what-is-the-fourier-transform-actually-doing" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;TOszYv0pdKU&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/TOszYv0pdKU"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>The Fourier transform represents the data <span class="math notranslate nohighlight">\(x\)</span> as a linear combination of sinusoids with different frequencies. To see this, consider again:</p>
<div class="math notranslate nohighlight">
\[
  X_j = \sum_{n=1}^{N}x_n \exp(-2\pi i f_j t_n).
\]</div>
<p>What is this expression actually doing? Let’s consider this equation piece by piece. The first term,</p>
<div class="math notranslate nohighlight">
\[
  \sum_{n=1}^N
\]</div>
<p>represents a sum over the indices of <span class="math notranslate nohighlight">\(x_n\)</span>. Because each subsequent index represents a step forward in time of <span class="math notranslate nohighlight">\(\Delta\)</span>, this sum represents a sum over time. In fact, this sum extends from the first index (<span class="math notranslate nohighlight">\(n=1\)</span>) to the last index (<span class="math notranslate nohighlight">\(n = N\)</span>) of the data, so the summation occurs over the entire duration of the recording. Adding the second term,</p>
<div class="math notranslate nohighlight">
\[
  \sum_{n=1}^N x_n
\]</div>
<p>the summation now acts on the data <span class="math notranslate nohighlight">\(x_n\)</span>, so we’re summing up the data over all indices or equivalently over the entire time of recording. The third term,</p>
<div class="math notranslate nohighlight">
\[
  \exp(-2\pi i f_j t_n),
\]</div>
<p>consists of an exponential (<span class="math notranslate nohighlight">\(\exp\)</span>) operating on the product of five individual terms, each of which is a number. The first two numbers are simple: <span class="math notranslate nohighlight">\(-2 \pi\)</span>. The third number is <span class="math notranslate nohighlight">\(i \equiv \sqrt{-1}\)</span>, a quantity representing an <em>imaginary unit</em>. The utility of the imaginary unit is that we can rewrite the exponential as the sum of a sine and cosine function. Remember from caclulus the remarkable <a href="https://en.wikipedia.org/wiki/Euler%27s_formula" rel="external">Euler’s formula</a>:</p>
<div class="math notranslate nohighlight">
\[
  \exp(-2\pi i f_j t_n) = \cos(-2\pi f_j t_n) + i \sin(-2\pi f_j t_n).
\]</div>
<p>Notice that the <span class="math notranslate nohighlight">\(i\)</span> now appears multiplying the sine term, and not inside the arguments of either sinusoid. Both sinusoids operate on the product of <span class="math notranslate nohighlight">\(2\pi\)</span> and two terms, the frequency <span class="math notranslate nohighlight">\(f_j\)</span> and the time <span class="math notranslate nohighlight">\(t_n\)</span>. Rewriting the equation for the Fourier transform using Euler’s formula, we find<a id="eq:3.10"></a></p>
<p>\begin{equation}\tag{<em>}\label{eq:</em>}
X_j = \left(\sum_{n=1}^N x_n \cos(-2\pi f_j t_n) \right) + i\left(\sum_{n=1}^N x_n \sin(-2\pi f_j t_n)\right),
\end{equation}</p>
<p>where the summation is distributed over both terms.</p>
<p>Written in this way, the Fourier transform becomes easier to interpret. Let’s consider the first term of the equation above. For each index <span class="math notranslate nohighlight">\(n\)</span>, we multiply the data <span class="math notranslate nohighlight">\(x_n\)</span> by a cosine function evaluated at frequency <span class="math notranslate nohighlight">\(f_j\)</span> and time <span class="math notranslate nohighlight">\(t_n\)</span>. We then sum the results of this multiplication over all indices from <span class="math notranslate nohighlight">\(n=1\)</span> to <span class="math notranslate nohighlight">\(n=N\)</span>, or equivalently, from time <span class="math notranslate nohighlight">\(t_n = \Delta\)</span> to time <span class="math notranslate nohighlight">\(t_n =T\)</span>. So, we multiply the data by a cosine function at frequency <span class="math notranslate nohighlight">\(f_j\)</span> for each point in time and sum the product over time. The second term of the equation is like the first, except we multiply the data <span class="math notranslate nohighlight">\(x_n\)</span> by a sine function.</p>
<p>We may therefore think of the Fourier transform as comparing the data <span class="math notranslate nohighlight">\(x\)</span> to the sinusoids oscillating at frequency <span class="math notranslate nohighlight">\(f_j\)</span>. When the data and sinusoid at frequency <span class="math notranslate nohighlight">\(f_j\)</span> align the summation in the Fourier transform is large and the result <span class="math notranslate nohighlight">\(X_j\)</span> is a large number. When the data and sinusoid at frequency <span class="math notranslate nohighlight">\(f_j\)</span> do not align, the summation in the Fourier transform is small and <span class="math notranslate nohighlight">\(X_j\)</span> is a tiny number.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;PRoA5Zn_gbQ&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<iframe
    width="400"
    height="300"
    src="https://www.youtube.com/embed/PRoA5Zn_gbQ"
    frameborder="0"
    allowfullscreen
></iframe>
</div></div>
</div>
<p>To make these ideas more concrete, we can consider some simple examples. In these examples, the data <span class="math notranslate nohighlight">\(x\)</span> will be a perfect cosine with frequency 10 Hz.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tt</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Create a time variable (in seconds)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tt</span><span class="p">)</span>  <span class="c1"># Generate the data, a 10 Hz cosine</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>           <span class="c1"># Plot the result</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_142_0.png" src="_images/03_142_0.png" />
</div>
</div>
<p>Choosing <span class="math notranslate nohighlight">\(f_j = 4\)</span> Hz, we can construct a sine and cosine function each oscillating at 4 Hz.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fj</span> <span class="o">=</span> <span class="mi">4</span>                                 <span class="c1"># Set frequency</span>
<span class="n">fj_sin</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">fj</span> <span class="o">*</span> <span class="n">tt</span><span class="p">)</span>        <span class="c1"># construct sine wave</span>
<span class="n">fj_cos</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">fj</span> <span class="o">*</span> <span class="n">tt</span><span class="p">)</span>        <span class="c1"># ... and cosine</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>         <span class="c1"># Plot the data</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">fj_sin</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sine&#39;</span><span class="p">)</span>  <span class="c1"># ... and the sine</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">fj_cos</span><span class="p">,</span> <span class="s1">&#39;r:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span> <span class="c1"># ... and cosine</span>
<span class="n">legend</span><span class="p">()</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_144_0.png" src="_images/03_144_0.png" />
</div>
</div>
<p>Then, to perform the calculation of the Equation (*) we multiply the data <span class="math notranslate nohighlight">\(x\)</span> by the sinusoids at each point in time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">fj_sin</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">fj_cos</span><span class="p">)</span>  <span class="c1"># Plot the product of x with the sinusoids</span>
<span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Sine&#39;</span><span class="p">,</span> <span class="s1">&#39;Cosine&#39;</span><span class="p">])</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>         <span class="c1"># Show zero</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_146_0.png" src="_images/03_146_0.png" />
</div>
</div>
<p>Notice that the products alternate between positive and negative values throughout time.</p>
<div class="question">
<p><strong>Q.</strong> In this case, what is the approximate value of <span class="math notranslate nohighlight">\(X_j\)</span> when <span class="math notranslate nohighlight">\(f_j = 4\)</span> Hz?</p>
<p><strong>A.</strong> We know that <span class="math notranslate nohighlight">\(X_j\)</span> is the summation over time of the product of <span class="math notranslate nohighlight">\(x\)</span> and the sinusoids,</p>
<p>\begin{equation}
X_j = \left(\sum_{n=1}^N x_n \cos(-2\pi f_j t_n) \right) + i\left(\sum_{n=1}^N x_n \sin(-2\pi f_j t_n)\right),
\end{equation}</p>
<p>Above, we plotted these products over time. Because each product alternates between positive and negative values roughly equally over time, the summation of the product over time is approximately zero. We therefore conclude that both the real part (i.e., the cosine term) and the imaginary part (i.e. the sine term) are small and <span class="math notranslate nohighlight">\(X_j \approx 0 + 0i\)</span> when <span class="math notranslate nohighlight">\(f_j = 4\)</span> Hz.</p>
</div><p>In this case, the sinusoids at frequency <span class="math notranslate nohighlight">\(f_j = 4\)</span> Hz do not align with the data <span class="math notranslate nohighlight">\(x\)</span>, and <span class="math notranslate nohighlight">\(X_j\)</span> is nearly zero in both its real and imaginary parts. Now consider the case in which we choose <span class="math notranslate nohighlight">\(f_j = 10\)</span> Hz. With this choice of <span class="math notranslate nohighlight">\(f_j\)</span>, the data <span class="math notranslate nohighlight">\(x\)</span> and the cosine function align perfectly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fj</span> <span class="o">=</span> <span class="mi">10</span>                                <span class="c1"># Set the frequency</span>
<span class="n">fj_sin</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">fj</span> <span class="o">*</span> <span class="n">tt</span><span class="p">)</span>        <span class="c1"># Construct the sine wave</span>
<span class="n">fj_cos</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">fj</span> <span class="o">*</span> <span class="n">tt</span><span class="p">)</span>        <span class="c1"># ... and cosine wave</span>

<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>         <span class="c1"># Plot the data</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">fj_sin</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sine&#39;</span><span class="p">)</span>  <span class="c1"># ... and the sine</span>
<span class="n">plot</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">fj_cos</span><span class="p">,</span> <span class="s1">&#39;r:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">)</span> <span class="c1"># ... and cosine</span>
<span class="n">legend</span><span class="p">()</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_149_0.png" src="_images/03_149_0.png" />
</div>
</div>
<div class="question">
<p><strong>Q.</strong> Can you predict how the plot of the product of the data with the overlapping cosine function will look? Plot the product and check your prediction.</p>
</div><p>The product of the cosine function and the data is always non-negative, and therefore its summation over time results in a large positive number. In this case, the real part of <span class="math notranslate nohighlight">\(X_j\)</span> is large because the cosine function with frequency <span class="math notranslate nohighlight">\(f_j =10\)</span> Hz and the data <span class="math notranslate nohighlight">\(x\)</span> match. In this sense, the Fourier transform reveals the dominant frequencies of the underlying time series.</p>
<div class="question">
<p><strong>Q.</strong> What is the approximate value of the <em>imaginary</em> part of <span class="math notranslate nohighlight">\(X_j\)</span> for <span class="math notranslate nohighlight">\(f_j = 10\)</span> Hz? <em>Hint</em>: Consider the plot of the product of the sine function and the data.</p>
</div><p><a id="autocovariance"></a></p>
</div>
</div>
<div class="section" id="relation-of-the-spectrum-to-the-autocovariance">
<h2>Relation of the spectrum to the autocovariance.<a class="headerlink" href="#relation-of-the-spectrum-to-the-autocovariance" title="Permalink to this headline">¶</a></h2>
<p>We’ve introduced two tools for assessing dependent structure in the EEG data: the autocovariance and the spectrum. Remarkably, these two measures are related in an important way.</p>
<div class="math-note">
<p>The spectrum is the Fourier transform of the autocovariance.</p>
</div>
<p>The spectrum and autocovariance both assess dependent structure in the data but in different domains - the spectrum in the frequency domain and the autocovariance in the time domain. Notice that the spectrum <span class="math notranslate nohighlight">\(S_{xx, j}\)</span> <a href="Analysis%20of%20rhythmic%20activity.ipynb#eq:3.9" class="thumb"><span><img src="imgs/eq3-9.png"></span></a> is a function of frequency index <span class="math notranslate nohighlight">\(j\)</span>, while the autocovariance <span class="math notranslate nohighlight">\(r_{xx}[L]\)</span> <a href="Analysis%20of%20rhythmic%20activity.ipynb#eq:3.3" class="thumb"><span><img src="imgs/eq3-3.png"></span></a> is a function of time lag <span class="math notranslate nohighlight">\(L\)</span>. For the EEG data of interest here, the dominant 60 Hz rhythm manifests as periodicity in the autocovariance as a function of lag <a href="Analysis%20of%20rhythmic%20activity.ipynb#fig:3-4a" class="fig"><span><img src="imgs/3-4a.png"></span></a> and a peak in the spectrum as a function of frequency. <a href="Analysis%20of%20rhythmic%20activity.ipynb#fig:3.6" class="fig"><span><img src="imgs/3-6.png"></span></a> Although the two measures are related through the Fourier transform, each provides a different perspective on the dependent structure in the data. In practice, applying and visualizing both measures is often of use.</p>
<p>Here’s an associated mathematical nugget. The spectrum is the Fourier transform of <span class="math notranslate nohighlight">\(x\)</span> multiplied by its complex conjugate. That produces a real number (i.e., the imaginary part is 0), which is convenient for plotting and visualization. The autocovariance is necessarily symmetric with respect to lag, that is, <span class="math notranslate nohighlight">\(r_{xx}[L] = r_{xx}[-L]\)</span>. In other words, the autocovariance is an even function. The Fourier transform of an even function is real, so the Fourier transform of the autocovariance is also a real number, consistent with the values of the spectrum.</p>
<p><a id="multiple-linear-regression"></a></p>
</div>
<div class="section" id="relation-of-the-spectrum-to-multiple-linear-regression">
<h2>Relation of the Spectrum to Multiple Linear Regression<a class="headerlink" href="#relation-of-the-spectrum-to-multiple-linear-regression" title="Permalink to this headline">¶</a></h2>
<p>As a final perspective, we consider a statistical modeling approach, with the goal of characterizing the rhythms that appear in the EEG data. To develop this approach, we first introduce <em>linear regression</em>. The idea of linear regression is to express a response variable at time <span class="math notranslate nohighlight">\(n\)</span> (call it <span class="math notranslate nohighlight">\(x_n\)</span>) in terms of predictor variables (call them <span class="math notranslate nohighlight">\(z_{1n}, z_{2n},...,z_{pn}\)</span> for <span class="math notranslate nohighlight">\(p\)</span> predictor variables) as <a id="eq:3.11"></a></p>
<div class="math notranslate nohighlight">
\[
  x_n = \beta_0 + \beta_1z_{1n} + \beta_2z_{2n} + ... + \beta_pz_{pn} + \epsilon_n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_n\)</span> is a random variable. This formulation represents the model we use in <em>multiple linear regression</em>. The term multiple comes from the multiple predictors used. The term linear expresses the fact that each predictor appears linearly in the expression. The challenge is to identify the unknown coefficients (the  <span class="math notranslate nohighlight">\(\beta\)</span>’s) given the observed response and predictor variables. We note that the case of <span class="math notranslate nohighlight">\(p = 1\)</span> corresponds to simple linear regression; in that case, the goal is to fit the line,</p>
<div class="math notranslate nohighlight">
\[
  x_n = \beta_0 + \beta_1z_{1n} + \epsilon_N,
\]</div>
<p>with slope <span class="math notranslate nohighlight">\(\beta_1\)</span> and intercept <span class="math notranslate nohighlight">\(\beta_0\)</span>.</p>
<p>Let’s consider the application of multiple linear regression to the EEG data with a specific
purpose: to remove the 60 Hz line noise. Recall that we found that the spectrum was dominated by a 60 Hz peak. <a href="#fig:3.6" class="fig"><span><img src="imgs/3-6.png"></span></a> We expect this 60 Hz is due to electrical noise in the system, and this large noise peak may mask other interesting features occurring in the EEG data. Therefore, our analysis of the EEG data may benefit by removing this large 60 Hz signal. To do so, we first fit a multiple linear regression model to the data <span class="math notranslate nohighlight">\(x_n\)</span> with the following form,<a id="eq:3.12"></a></p>
<div class="math notranslate nohighlight">
\[
  x_n = \beta_0 + \beta_1 \sin(2\pi \cdot 60 t_n) + \beta_2\cos(2\pi \cdot 60 t_n) + \epsilon_n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(x_n\)</span> is the EEG data at index <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(t_n\)</span> is the corresponding time axis at index <span class="math notranslate nohighlight">\(n\)</span> in units of seconds, and <span class="math notranslate nohighlight">\(\epsilon_n\)</span> is a random variable.</p>
<div class="question">
<p><strong>Q.</strong> The model consists of three predictors. What are they?</p>
<p><strong>A.</strong> The predictors are a constant term, a sine function at 60 Hz, and a cosine function at 60 Hz. Our goal is to solve for the unknown coefficients <span class="math notranslate nohighlight">\(\beta_0,\ \beta_1,\)</span> and <span class="math notranslate nohighlight">\(\beta_2\)</span> given the EEG data.</p>
</div><p>To do multiple linear regression in Python we start by importing the <code class="docutils literal notranslate"><span class="pre">statsmodels</span></code> package and the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> function from the <code class="docutils literal notranslate"><span class="pre">pandas</span></code> package. We use <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to create a table that is easy to work with and then use <code class="docutils literal notranslate"><span class="pre">statsmodels</span></code> to perform the regression.</p>
<p>We will work with the same data set that we used in the main component of this notebook, so we start by importing the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/03_EEG-1.mat&#39;</span><span class="p">)</span>
<span class="n">EEG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Then let’s use the following code to perform the multiple linear regression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predictors</span> <span class="o">=</span> <span class="n">df</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span>            <span class="c1"># Create a dataframe with the predictors</span>
    <span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">t</span><span class="p">),</span>  <span class="c1"># ... including the sine function</span>
    <span class="s1">&#39;cos&#39;</span><span class="p">:</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">t</span><span class="p">),</span>  <span class="c1"># ... and the cosine function</span>
    <span class="s1">&#39;EEG&#39;</span><span class="p">:</span> <span class="n">EEG</span>
<span class="p">})</span>
                                  <span class="c1"># Fit the model to the data</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">ols</span><span class="p">(</span><span class="s1">&#39;EEG ~ sin + cos&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">predictors</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Intercept    2.818926e-17
sin          9.989204e-01
cos         -3.238373e-03
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>In the first line, we create a <em>dataframe</em> object with the dependent variables (<code class="docutils literal notranslate"><span class="pre">EEG</span></code>) and independent variables (or predictors) of the model - in this case the 60 Hz sine function, and the 60 Hz cosine function. Next, we fit the model to the data using the <code class="docutils literal notranslate"><span class="pre">ols</span></code> function. OLS stands for <a href="https://en.wikipedia.org/wiki/Ordinary_least_squares" rel="external">ordinary least squares</a> because Python determines the coefficients by minimizing the squared distance between the true and predicted data points. The last line shows us the values that Python has found for the <span class="math notranslate nohighlight">\(\beta\)</span>’s.</p>
<div class="question">
<p><strong>Q.</strong> Examine the fitted <span class="math notranslate nohighlight">\(\beta\)</span> values. What do you find?</p>
<p><strong>A.</strong> We find</p>
<div style="margin: .25in; background-color: #eff0f1">
<p><code>Intercept    2.8e-17
sin          9.99e-01
cos         -3.24e-03</p>
<p>dtype: float64</code></div></p>
<p>This result indicates that the constant predictor and the 60 Hz cosine predictor do not contribute much to the data; the values of the coefficients for the predictors <code class="docutils literal notranslate"><span class="pre">Intercept</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> are both near zero. However, the 60 Hz sine function makes a much larger contribution; the value of the coefficient for the predictor <code class="docutils literal notranslate"><span class="pre">sin</span></code> is near 1.</p>
</div><p>To see how well our multiple linear regression model fits the data, let’s evaluate the model, and compare it to the original EEG data:
<a id='fig:3.8'></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">EEG_60Hz_modeled</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>    <span class="c1"># Get the model prediction</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">EEG</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">EEG_60Hz_modeled</span><span class="p">)</span>     <span class="c1"># Plot the data and the model</span>
<span class="n">xlim</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>                        <span class="c1"># ... examine 0.5 s of data,</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>                    <span class="c1"># ... and label the axes</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;EEG and Modeled EEG [$\mu$V]&#39;</span><span class="p">)</span>
<span class="n">legend</span><span class="p">([</span><span class="s1">&#39;EEG&#39;</span><span class="p">,</span> <span class="s1">&#39;model&#39;</span><span class="p">])</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_161_0.png" src="_images/03_161_0.png" />
</div>
</div>
<p>The model, which contains only three predictors, appears to do quite a good job at capturing the 60 Hz activity in the EEG data.</p>
<div class="question">
<p><strong>Q.</strong> The multiple linear regression model <a href="#eq:3.12" class="thumb"><span><img src="imgs/eq3-12.png"></span></a> is not a <em>perfect</em> fit ot the data. Why?</p>
<p><strong>A.</strong> The multiple linear regression model includes only three predictors. We expect the EEG data to consist of other features, including rhythms at other frequencies. Therefore, this simple model cannot account for all features of the EEG time series. That’s okay. The goal of this model was to fit a particular rhythm, the 60 Hz activity, not every aspect of the data.</p>
</div><p>Now, let’s examine a powerful application of the model. We’ve constructed the model to fit the 60 Hz line noise in the EEG data. Let’s now use the model to <em>remove</em> the 60 Hz line noise from the original EEG data. To do so, we subtract the model fit from the EEG data and then plot the resulting new signal: <a id="fig:3.9"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Remove the model prediction from the EEG data</span>
<span class="n">EEG_cleaned</span> <span class="o">=</span> <span class="n">EEG</span> <span class="o">-</span> <span class="n">EEG_60Hz_modeled</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">EEG_cleaned</span><span class="p">)</span>  <span class="c1"># ... and plot the result</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;EEG Cleaned [$\mu$V]&#39;</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03_164_0.png" src="_images/03_164_0.png" />
</div>
</div>
<div class="question">
<p><strong>Q.</strong> Consider the cleaned EEG data. What activity do you now notice? Compare the EEG data in the plot you created above to the <a class="reference external" href="#fig:3-1">original EEG data</a>, which includes the 60 Hz noise.<span class="sup">fig<img src="imgs/3-1.png"></span> What’s different?</p>
</div><p>In this example, we used multiple linear regression to model a particular rhythmic component of the EEG data, the 60 Hz activity. We may also use the model result to estimate the power at 60 Hz. In Python,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sxx_model_60Hz</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">Sxx_model_60Hz</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>0.9978524145209726
</pre></div>
</div>
</div>
</div>
<p>The power estimate from the model consists of two terms: the squared coefficient of the sine function plus the squared coefficient of the cosine function. Note that the variable <code class="docutils literal notranslate"><span class="pre">Sxx_model_60Hz</span></code> has units of mV<span class="math notranslate nohighlight">\(^2\)</span>.</p>
<div class="question">
<p><strong>Q.</strong> Compare the power estimate from the model (the variable <code class="docutils literal notranslate"><span class="pre">Sxx_model_60Hz</span></code>) to the power spectral density at 60 Hz computed using the Fourier transform. What do you find?</p>
<p><strong>A.</strong> We note that the units of the power spectral density (variable <code class="docutils literal notranslate"><span class="pre">Sxx</span></code>) are mV<span class="math notranslate nohighlight">\(^2/\)</span>Hz, while the units of the power estimated in variable <code class="docutils literal notranslate"><span class="pre">Sxx_model_60Hz</span></code> are mV<span class="math notranslate nohighlight">\(^2\)</span>. To convert the power spectral density to (integrated) spectral power, we must integrate the variable <code class="docutils literal notranslate"><span class="pre">Sxx</span></code> over a frequency range. Here, we choose a 1 Hz interval centered at 60 Hz, which corresponds to a single index of the variable <code class="docutils literal notranslate"><span class="pre">faxis</span></code>; the frequency resolution for these data is <span class="math notranslate nohighlight">\(\pm 0.5\)</span> Hz. Then the approximate integrated power over this 1 Hz interval can be computed as <code class="docutils literal notranslate"><span class="pre">Sxx[where(faxis</span> <span class="pre">==</span> <span class="pre">60)]</span></code>, which equals 0.9978, identical to the value in <code class="docutils literal notranslate"><span class="pre">Sxx_model_60Hz</span></code>, and with the same units.</p>
</div><p>This example, in which we focused on the 60 Hz activity in the EEG, illustrates how we may use multiple linear regression to estimate the power. We could extend this procedure to include additional rhythms in the model beyond 60 Hz (e.g., sine and cosine functions at 1 Hz, 2 Hz, 3 Hz, etc.). In doing so, we would add more terms to the multiple linear regression model and have more <span class="math notranslate nohighlight">\(\beta\)</span>’s to determine from the data. Multiple linear regression provides a way to decompose the EEG data into sine and cosine functions at different frequencies—just as we proposed to do using the Fourier transform—and then compute the power at each frequency. Using either multiple linear regression or the Fourier transform, we aim to decompose the EEG into sine and cosine functions oscillating at different frequencies.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "Mark-Kramer/Case-Studies-Python",
            ref: "binder",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "."
        }
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="02.html" title="previous page">The Event-Related Potential</a>
    <a class='right-next' id="next-link" href="04.html" title="next page">The Power Spectrum (Part 2)</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Mark Kramer and Uri Eden<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="_static/js/index.js"></script>
    
    <!-- Google Analytics -->
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'G-54QV706BYJ', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    <!-- End Google Analytics -->
    
  </body>
</html>