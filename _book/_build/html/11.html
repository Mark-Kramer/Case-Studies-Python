

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Analysis of spike-field cohernece for the practicing neuroscientist &#8212; Case Studies in Neural Data Analysis</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/mystnb.js"></script>
    <script src="_static/custom.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="canonical" href="https://mark-kramer.github.io/Case-Studies-Python/11.html" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Backpropagation" href="A01.html" />
    <link rel="prev" title="Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task" href="10.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">


<!-- Opengraph tags -->
<meta property="og:url"         content="https://mark-kramer.github.io/Case-Studies-Python/11.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Analysis of spike-field cohernece <em>for the practicing neuroscientist</em> <a id="top"></a>" />
<meta property="og:description" content="Analysis of spike-field cohernece for the practicing neuroscientist <a id="top"></a>  <div class="question">   Synopsis  Data: 100 trials of 1 s of local field " />
<meta property="og:image"       content="https://mark-kramer.github.io/Case-Studies-Python/_static/logo.png" />

<meta name="twitter:card" content="summary">


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Case Studies in Neural Data Analysis</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  
  <ul class="nav sidenav_l1">
  <li class="">
    <a href="01.html">1. Python for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="02.html">2. The Event-Related Potential for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="03.html">3. Analysis of rhythmic activity for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="04.html">4. The Power Spectrum (Part 2)</a>
  </li>
  <li class="">
    <a href="05.html">5. Analysis of coupled rhythms for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="06.html">6. Application of Filtering to Scalp EEG Data</a>
  </li>
  <li class="">
    <a href="07.html">7. Cross-frequency coupling for the practicing neuroscientist</a>
  </li>
  <li class="">
    <a href="08.html">8. Basic Visualizations and Descriptive Statistics of Spike Train Data</a>
  </li>
  <li class="">
    <a href="09.html">9. Modeling Place Fields with Point Process Generalized Linear Models</a>
  </li>
  <li class="">
    <a href="10.html">10. Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</a>
  </li>
  <li class="active">
    <a href="">11. Analysis of spike-field cohernece for the practicing neuroscientist <a id="top"></a></a>
  </li>
<li class="navbar-special">
<p class="margin-caption">Appendices</p>
</li>
  <li class="">
    <a href="A01.html">12. Backpropagation</a>
  </li>
  <li class="">
    <a href="A02.html">13. The Hodgkin-Huxley model</a>
  </li>
  <li class="">
    <a href="A03.html">14. The integrate and fire neuron</a>
  </li>
  <li class="">
    <a href="A04.html">15. Training a Perceptron</a>
  </li>
</ul>
</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse" data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation" title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i class="fas fa-download"></i></button>

            
            <div class="dropdown-buttons">
                <!-- ipynb file if we had a myst markdown file -->
                
                <!-- Download raw file -->
                <a class="dropdown-buttons" href="_sources/11.ipynb"><button type="button" class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip" data-placement="left">.ipynb</button></a>
                <!-- Download PDF via print -->
                <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF" onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
            </div>
            
        </div>

        <!-- Source interaction buttons -->
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
            <div class="dropdown-buttons sourcebuttons">
                <a class="repository-button" href="https://github.com/eschlaf2/Case-Studies-Python"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left" title="Source repository"><i class="fab fa-github"></i>repository</button></a>
                <a class="issues-button" href="https://github.com/eschlaf2/Case-Studies-Python/issues/new?title=Issue%20on%20page%20%2F11.html&body=Your%20issue%20content%20here."><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left" title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
                
            </div>
        </div>
        

        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->
        
        <div class="dropdown-buttons-trigger">
            <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
            <div class="dropdown-buttons">
                
                <a class="binder-button" href="https://mybinder.org/v2/gh/eschlaf2/Case-Studies-Python/master?urlpath=tree/_book/11.ipynb"><button type="button" class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip" data-placement="left"><img class="binder-button-logo" src="_static/images/logo_binder.svg" alt="Interact on binder">Binder</button></a>
                
                
                
            </div>
        </div>
        
    </div>
    <div class="d-none d-md-block col-md-2 bd-toc show">
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#on-ramp-computing-the-spike-field-coherence-in-python" class="nav-link">On-ramp: computing the spike-field coherence in Python</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#introduction" class="nav-link">Introduction</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#case-study-data" class="nav-link">Case study data</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#goals" class="nav-link">Goals</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#tools" class="nav-link">Tools</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#data-analysis-a-id-data-analysis-a" class="nav-link">Data analysis<a id="data-analysis"></a></a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#step-1-visual-inspection-a-id-visual-inspection-a" class="nav-link">Step 1: Visual inspection<a id="visual-inspection"></a></a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#spike-triggered-average-a-id-sta-a" class="nav-link">Spike-Triggered Average<a id="STA"></a></a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#field-triggered-average-a-id-fta-a" class="nav-link">Field-Triggered Average<a id="FTA"></a></a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#spike-field-coherence-a-id-sec-spike-field-coherence-a" class="nav-link">Spike-field coherence <a id="sec:spike-field-coherence"></a></a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#mathematical-description-of-spike-field-coherence" class="nav-link">Mathematical description of spike-field coherence</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#computing-the-spike-field-coherence-in-python" class="nav-link">Computing the Spike-Field-Coherence in Python.</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#the-impact-of-firing-rate-on-the-spike-field-coherence" class="nav-link">The Impact of Firing Rate on the Spike-Field Coherence</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#thinning-the-spike-train-a-id-sec-thin-a" class="nav-link">Thinning the spike train <a id="sec:thin"></a></a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#point-process-models-of-the-spike-field-coherence-a-id-sec-point-process-model-a" class="nav-link">Point Process Models of the Spike-Field Coherence<a id="sec:point-process-model"></a></a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#summary" class="nav-link">Summary</a>
        </li>
    
    </ul>
</nav>


    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="analysis-of-spike-field-cohernece-for-the-practicing-neuroscientist-a-id-top-a">
<h1>Analysis of spike-field cohernece <em>for the practicing neuroscientist</em> <a id="top"></a><a class="headerlink" href="#analysis-of-spike-field-cohernece-for-the-practicing-neuroscientist-a-id-top-a" title="Permalink to this headline">¶</a></h1>
<div class="question">
<p><em><strong>Synopsis</strong></em></p>
<p><strong>Data:</strong> 100 trials of 1 s of local field potential and spike train data sampled at 1000 Hz.</p>
<p><strong>Goal:</strong> Characterize the coupling between the spike and field activity.</p>
<p><strong>Tools:</strong> Fourier transform, spectrum, coherence, phase, generalized linear models.</p>
</div><ul class="simple">
<li><p><a class="reference external" href="#onramp">On-ramp</a></p></li>
<li><p><a class="reference external" href="#intro">Introduction</a></p></li>
<li><p><a class="reference external" href="#data-analysis">Data analysis</a></p>
<ol class="simple">
<li><p><a class="reference external" href="#visual-inspection">Visual inspection</a></p></li>
<li><p><a class="reference external" href="#STA">Spike-Triggered Average</a></p></li>
<li><p><a class="reference external" href="#FTA">Field-Triggered Average</a></p></li>
<li><p><a class="reference external" href="#sec:spike-field-coherence">Spike-field coherence</a></p></li>
<li><p><a class="reference external" href="#sec:point-process-model">Point Process Models of the Spike-Field Coherence</a></p></li>
</ol>
</li>
<li><p><a class="reference external" href="#summary">Summary</a></p></li>
</ul>
<p><a id="onramp"></a></p>
<div class="section" id="on-ramp-computing-the-spike-field-coherence-in-python">
<h2>On-ramp: computing the spike-field coherence in Python<a class="headerlink" href="#on-ramp-computing-the-spike-field-coherence-in-python" title="Permalink to this headline">¶</a></h2>
<p>We begin this module with an “<em>on-ramp</em>” to analysis. The purpose of this on-ramp is to introduce you immediately to a core concept in this module: how to compute the spike-field cohernece in Python. You may not understand all aspects of the program here, but that’s not the point. Instead, the purpose of this on-ramp is to  illustrate what <em>can</em> be done. Our advice is to simply run the code below and see what happens …</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Load the data and plot it.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/spikes-LFP-1.mat&#39;</span><span class="p">)</span>       <span class="c1"># Load the multiscale data,</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>                                <span class="c1"># ... get the LFP data,</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>                                <span class="c1"># ... get the spike data,</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                    <span class="c1"># ... get the time axis,</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                           <span class="c1"># Get the number of trials,</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>                           <span class="c1"># ... and the number of data points in each trial,</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                               <span class="c1"># Get the sampling interval.</span>

<span class="n">SYY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>                                       <span class="c1"># Variable to store field spectrum.</span>
<span class="n">SNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>                                       <span class="c1"># Variable to store spike spectrum.</span>
<span class="n">SYN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>                        <span class="c1"># Variable to store cross spectrum.</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>                                           <span class="c1"># For each trial,</span>
    <span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]))</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>    <span class="c1"># Hanning taper the field,</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:])))</span>                   <span class="c1"># ... but do not taper the spikes.</span>
    <span class="n">SYY</span> <span class="o">=</span> <span class="n">SYY</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Field spectrum</span>
    <span class="n">SNN</span> <span class="o">=</span> <span class="n">SNN</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">nf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Spike spectrum</span>
    <span class="n">SYN</span> <span class="o">=</span> <span class="n">SYN</span> <span class="o">+</span> <span class="p">(</span>          <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span>   <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Cross spectrum</span>

<span class="n">cohr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">SYN</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">SYN</span><span class="p">))</span> <span class="o">/</span> <span class="n">SYY</span> <span class="o">/</span> <span class="n">SNN</span>                     <span class="c1"># Spike-field coherence</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>                                       <span class="c1"># Frequency axis for plotting</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">)</span>                             <span class="c1"># Plot the result.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_4_0.png" src="_images/11_4_0.png" />
</div>
</div>
<div class="question">
<p><strong>Q:</strong> Try to read the code above. Can you see how it loads data, computes the spike-field coherence, and then plots the results?</p>
<p><strong>A:</strong> If you’ve never computed the spike-field cohernece before, that’s an especially difficult question. Please continue on to learn this <strong>and more</strong>!</p>
</div><p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="intro"></a></p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In other modules, we focused on two types of data: field data (e.g., EEG, ECoG, LFP) and spiking data (i.e., action potentials), and we developed techniques to analyze these data. In this module, we consider the simultaneous observation of both data types. We analyze these multiscale data using the techniques developed in other modules and focus specifically on computing the coherence between the spike and field recordings. Understanding the relations between activity recorded at different spatial scales (i.e., a macroscopic field and microscopic spikes) remains an active research area.</p>
<div class="section" id="case-study-data">
<h3>Case study data<a class="headerlink" href="#case-study-data" title="Permalink to this headline">¶</a></h3>
<p>Our experimental collaborator has implanted an electrode in rat hippocampus as the animal performs a task requiring navigation and decision making. From these data, he is able to extract the local field potential (LFP) as well as the spiking activity of a single neuron. He would like to characterize how these multiscale data—the population field activity and the single neuron spiking activity—relate. Based on existing evidence in the literature and experimental intuition, he expects that rhythmic activity in the LFP impacts the probability that a spike will occur. As his collaborator, we will help him to develop tools to examine this hypothesis. He provides us with 100 trials of simultaneous LFP and spike train data with a sampling frequency of 1000 Hz. The duration of each trial is 1 s, corresponding to a fixed temporal interval following a particular decision of the rat.</p>
</div>
<div class="section" id="goals">
<h3>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h3>
<p>Our goal is to understand the coupling between the spiking activity and the LFP following the stimulus. To do so, we analyze the multiscale data recorded simultaneously. To assess this coupling, we will start with two visualizations of the data: the spike-triggered average and the field-triggered average. We then compute the spike-field coherence, a coupling measure that builds upon the Fourier transform and spectrum. We also examine how the firing rate impacts measures of coupling and how to mitigate this impact.</p>
</div>
<div class="section" id="tools">
<h3>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h3>
<p>In this module, we focus primarily on computing the spike-field coherence. Development of this measure makes use of skills developed in other modules. In computing the spike-field coherence, we continue to utilize the Fourier transform. We also consider how generalized linear models (GLMs) can be used to construct a measure of spike-field association with an important advantage over the spike-field coherence.</p>
<p><a class="reference external" href="#top">Return to top</a></p>
</div>
</div>
<div class="section" id="data-analysis-a-id-data-analysis-a">
<h2>Data analysis<a id="data-analysis"></a><a class="headerlink" href="#data-analysis-a-id-data-analysis-a" title="Permalink to this headline">¶</a></h2>
<p>We will go through the following steps to analyze the data:</p>
<ol class="simple">
<li><p><a class="reference external" href="#visual-inspection">Visual inspection</a></p></li>
<li><p><a class="reference external" href="#STA">Spike-Triggered Average</a></p></li>
<li><p><a class="reference external" href="#FTA">Field-Triggered Average</a></p></li>
<li><p><a class="reference external" href="#sec:spike-field-coherence">Spike-field coherence</a></p></li>
<li><p><a class="reference external" href="#sec:point-process-model">Point Process Models of the Spike-Field Coherence</a></a></p></li>
</ol>
<div class="section" id="step-1-visual-inspection-a-id-visual-inspection-a">
<h3>Step 1: Visual inspection<a id="visual-inspection"></a><a class="headerlink" href="#step-1-visual-inspection-a-id-visual-inspection-a" title="Permalink to this headline">¶</a></h3>
<p>We begin the analysis by visualizing examples of the simultaneously recorded spike train and LFP data. Let’s load these multi-scale data into Python and plot the activity of the first trial:<a id='fig:LFP_ex'></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Prepare the modules and plot settings</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">sio</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">setup</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="c1"># Load the data and plot it.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;matfiles/spikes-LFP-1.mat&#39;</span><span class="p">)</span>  <span class="c1"># Load the multiscale data,</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>                                <span class="c1"># ... get the LFP data,</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>                                <span class="c1"># ... get the spike data,</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>                    <span class="c1"># ... get the time axis,</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span>                               <span class="c1"># ... and visualize the data, for the first trial.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                    <span class="c1"># ... with white space minimized.</span>
<span class="n">savefig</span><span class="p">(</span><span class="s2">&quot;imgs/lfp_ex&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_11_0.png" src="_images/11_11_0.png" />
</div>
</div>
<div class="python-note">
<p><strong>Array shapes:</strong> The <code class="docutils literal notranslate"><span class="pre">reshape()</span></code> function lets us change the shape of an array. <code class="docutils literal notranslate"><span class="pre">reshape(-1)</span></code> tells Python to reshape the array into a vector with as many elements as are in the array. Mathematically, a vector is a one-dimensional array. In Python, the difference is that a vector is indexed by a single number, while an array is indexed by multiple numbers. After reshaping, we can look at the number at index 0 of <code class="docutils literal notranslate"><span class="pre">t</span></code> using <code class="docutils literal notranslate"><span class="pre">t[0]</span></code>. If we don’t reshape first, we need to use <code class="docutils literal notranslate"><span class="pre">t[0,</span> <span class="pre">0]</span></code> to get the same result, so reshaping the array isn’t required, but it is more convenient. There is a nice explanation of array shapes <a class="reference external" href="https://stackoverflow.com/questions/22053050/difference-between-numpy-array-shape-r-1-and-r#answer-22074424">here</a>.</p>
</div><p>The data file consists of three variables, which correspond to the LFP data (<code class="docutils literal notranslate"><span class="pre">y</span></code>, in units of millivolts), the simultaneously recorded spiking activity (<code class="docutils literal notranslate"><span class="pre">n</span></code>), and a time axis (<code class="docutils literal notranslate"><span class="pre">t</span></code>, in units of seconds). Notice that the data are arrays, in which each row indicates a separate trial, and each column indicates a point in time. In this case, the variable <code class="docutils literal notranslate"><span class="pre">n</span></code> is binary; <code class="docutils literal notranslate"><span class="pre">n[k,i]=1</span></code> indicates a spike in trial <code class="docutils literal notranslate"><span class="pre">k</span></code> at time index <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<div class="question">
<p><strong>Q.</strong> What is the sampling frequency for these data?</p>
<p><strong>A.</strong> We are given the time axis <code class="docutils literal notranslate"><span class="pre">t</span></code>. To compute the sampling frequency, we compute the sampling interval: <code class="docutils literal notranslate"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">t[2]-t[1]</span></code> and find <code class="docutils literal notranslate"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">0.001</span></code>. The sampling interval is therefore 1 ms, so the sampling frequency ( <span class="math notranslate nohighlight">\(f\)</span> ) is <span class="math notranslate nohighlight">\(f = 1/dt = 1000\)</span> Hz.</p>
</div><p>We plotted the data for first trial in the figure above<a href="fig:LFP_ex" class="sup">fig<img src="imgs/lfp_ex.png"></a>. Visual inspection immediately suggests that the LFP data exhibit a dominant rhythm. By counting the number of peaks (or troughs) in 1 s of data, we estimate the dominant rhythm to be <span class="math notranslate nohighlight">\(\approx\)</span> 10 Hz. However, careful inspection suggests that other features appear in the LFP from this first trial of data (i.e., additional lower-amplitude wiggles in the signal). Let’s keep this in mind as we continue the analysis. To visualize the spikes from the neuron, we plot the activity in the first row of the data matrix (orange curve in the figure above); this is a crude representation of the activity but sufficient for the initial inspection.</p>
<div class="question">
<p><strong>Q.</strong>  Continue your visual inspection for other trials of the data. What do you observe?</p>
</div><p>Visual inspection suggests that the neuron is active (i.e., it spikes) during the trial. Of course, we may visualize and analyze features of the spike train and the LFP using a variety of differnt methods (e.g., <strong>see problem 1</strong>). However, our goal here is to characterize the relation (if any) between the LFP and spikes. Let’s consider a relatively simple characterization of this relation, the spike-triggered average.</p>
</div>
</div>
<div class="section" id="spike-triggered-average-a-id-sta-a">
<h2>Spike-Triggered Average<a id="STA"></a><a class="headerlink" href="#spike-triggered-average-a-id-sta-a" title="Permalink to this headline">¶</a></h2>
<p>The <em>spike-triggered average</em> (STA) is a relatively simple procedure to visualize the relation between the LFP and spiking data. To compute the STA, we implement the following procedure.</p>
<p>For each trial <span class="math notranslate nohighlight">\(k = {1,...,K}\)</span>, do the following:</p>
<ul class="simple">
<li><p>Identify the time of each spike occurrence <span class="math notranslate nohighlight">\(t_{k,i}\)</span>, where <span class="math notranslate nohighlight">\(i \in \{1,...,N_k\}\)</span>, and <span class="math notranslate nohighlight">\(N_{k}\)</span> is the number of spikes in the <span class="math notranslate nohighlight">\(k^{th}\)</span> trial.</p></li>
<li><p>For each spike time <span class="math notranslate nohighlight">\(t_{k,i}\)</span>, determine the LFP within a small temporal interval near the spike time <span class="math notranslate nohighlight">\(LFP_{k,i}\)</span>.</p></li>
<li><p>Average <span class="math notranslate nohighlight">\(LFP_{k,i}\)</span> across all spikes.</p></li>
</ul>
<p>Despite this seemingly complicated descriptions, the STA is a relatively intuitive measure. The intuition is to find each spike and determine how the LFP changes nearby. The procedure to compute the STA for each trial is relatively straightforward to perform in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="mi">100</span>                                      <span class="c1"># Define a temporal window to examine around each spike.</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                             <span class="c1"># Get the number of trials,</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>                             <span class="c1"># ... and the number of data points in each trial.</span>
<span class="n">STA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">win</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>                    <span class="c1"># Define a variable to hold the STA.</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>                         <span class="c1"># For each trial,</span>
    <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># ... find the spikes.</span>
    <span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">spike_t</span> <span class="ow">in</span> <span class="n">spike_times</span><span class="p">:</span>                <span class="c1"># For each spike,</span>
        <span class="k">if</span> <span class="n">win</span> <span class="o">&lt;</span> <span class="n">spike_t</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="n">win</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>            <span class="c1"># ... add the LFP to the STA.</span>
            <span class="n">STA</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">STA</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">spike_t</span><span class="o">-</span><span class="n">win</span><span class="p">:</span><span class="n">spike_t</span><span class="o">+</span><span class="n">win</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">STA</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">STA</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">/</span><span class="n">counter</span>
</pre></div>
</div>
</div>
</div>
<p>In this Python code, we must be careful to include only appropriate time intervals when computing the STA.</p>
<div class="question">
<p><strong>Q.</strong> Q: What is the purpose of the if-statement:</p>
<p><code class="docutils literal notranslate"> <span class="pre">if</span> <span class="pre">win</span> <span class="pre">&lt;</span> <span class="pre">spike_t</span> <span class="pre">&lt;</span> <span class="pre">N-win-1:</span></code></p>
<p>in the code?</p>
</div><p>Notice that the variable <code class="docutils literal notranslate"><span class="pre">STA</span></code> is a matrix, with each row corresponding to a separate trial. Let’s plot the results for the STA in four trials<a id="plt:STA"></a>,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                    <span class="c1"># Get the sampling interval.</span>
<span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">win</span><span class="p">,</span><span class="n">win</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span>   <span class="c1"># Make a time axis for plotting.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">STA</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>              <span class="c1"># Show the STA for 4 trials.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">STA</span><span class="p">[</span><span class="mi">5</span><span class="p">,:])</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">STA</span><span class="p">[</span><span class="mi">9</span><span class="p">,:])</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">STA</span><span class="p">[</span><span class="mi">15</span><span class="p">,:])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [ms]&#39;</span><span class="p">)</span>               <span class="c1"># With axes labeled.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage [mV]&#39;</span><span class="p">);</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/sta&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_24_0.png" src="_images/11_24_0.png" />
</div>
</div>
<p>And, let’s plot the STA results across <em>all</em> trials,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">STA</span><span class="p">))</span>        <span class="c1"># Plot the STA results across all trials.</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time [ms]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage [mV]&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_26_0.png" src="_images/11_26_0.png" />
</div>
</div>
<p>The individual trial results suggest an approximate rhythmicity in the STA; visual inspection reveals that the STA fluctuates with a period of approximately 100 ms. However, these fluctuations are not phase-locked across trials. For some trials, the LFP tends to be positive when the cell spikes (i.e., at <span class="math notranslate nohighlight">\(t = 0\)</span> in the figure), while in other trials the LFP tends to be negative when the cell spikes. The initial results do not suggest a consistent relation exists between the spikes and the LFP across trials.</p>
<p>However, let’s not abandon all hope yet. We might be concerned that the rhythmicity in the STA<a href="#plt:STA" class="sup">fig<img src="imgs/sta.png"></a> is consistent with the dominant rhythm of the LFP.<a href="#plt:LFP_ex" class="sup">fig<img src="imgs/lfp_ex.png"></a>.\ Because the STA is an average of the LFP, we might expect the largest-amplitude features of the LFP to make the biggest impact on the STA. Perhaps this large-amplitude rhythm in the LFP is hiding more subtle features embedded in lower-amplitude activity in the LFP … Let’s continue the search.</p>
<div class="question">
<p><strong>Q.</strong> How would you update the preceding Python code to compute both the average LFP (i.e., the STA) and the standard deviation of the LFP across spikes for each trial?</p>
</div></div>
<div class="section" id="field-triggered-average-a-id-fta-a">
<h2>Field-Triggered Average<a id="FTA"></a><a class="headerlink" href="#field-triggered-average-a-id-fta-a" title="Permalink to this headline">¶</a></h2>
<p>Let’s now implement another visualization, the field-triggered average (FTA). The FTA is similar in principle to the STA. However, for the FTA, we use the field to organize the activity of the spikes (i.e., we use the field to trigger the spikes). Here we choose a particular feature of the field: the phase. The phase of neural signals is throught to play an <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4605134/">important role in organizing brain activity</a>. Now we examine the role of the LFP phase in organizing the spiking activity.</p>
<p>To compute the FTA, we implement the following prescription:</p>
<p>For each trial <span class="math notranslate nohighlight">\(k = \{1, \ldots, K\}\)</span>,</p>
<ul class="simple">
<li><p>Filter the LFP data in trial <span class="math notranslate nohighlight">\(k\)</span> into a narrow band, and apply the <a class="reference external" href="https://en.wikipedia.org/wiki/Hilbert_transform">Hilbert transform</a> to estimate the instantaneous phase.</p></li>
<li><p>Sort the spike data in trial <span class="math notranslate nohighlight">\(k\)</span> according to the phase of the LFP.</p></li>
</ul>
<p>For more information about the Hilbert transform and instantaneous phase, check out this module discussing <a class="reference external" href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/5.%20Cross-Frequency%20Coupling">cross-frequency coupling</a>. We apply the same procedures here, but to a different end. Let’s now define a function to compute the FTA in Python, <a id="fig:FTA"></a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">FTA_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Wn</span><span class="p">):</span>                  <span class="c1">#INPUTS: y=field, n=spikes, t=time, Wn=passband [low,high]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                           <span class="c1">#Define the sampling interval.</span>
    <span class="n">fNQ</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span>                             <span class="c1">#Define the Nyquist frequency.</span>
    <span class="nb">ord</span>  <span class="o">=</span> <span class="mi">100</span>                               <span class="c1">#...and filter order,</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="n">fNQ</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">);</span> <span class="c1">#...build bandpass filter.</span>
    <span class="n">FTA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>                      <span class="c1">#Create a variable to hold the FTA.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>                   <span class="c1">#For each trial,</span>
        <span class="n">Vlo</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>  <span class="c1"># ... apply the filter.</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">Vlo</span><span class="p">))</span>  <span class="c1"># Compute the phase of low-freq signal</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>            <span class="c1">#... get indices of sorted phase,</span>
        <span class="n">FTA</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">indices</span><span class="p">]</span>              <span class="c1">#... and store the sorted spikes.</span>
    <span class="n">phi_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>   <span class="c1">#Compute phase axis for plotting.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">FTA</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">phi_axis</span>

<span class="n">Wn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>                                  <span class="c1">#Define the passband, here from 9-11 Hz.</span>
<span class="n">FTA</span><span class="p">,</span> <span class="n">phi_axis</span> <span class="o">=</span> <span class="n">FTA_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Wn</span><span class="p">)</span>       <span class="c1">#Compute the FTA.</span>

<span class="c1">#Plot the average FTA versus phase.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">phi_axis</span><span class="p">,</span> <span class="n">FTA</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Phase&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;FTA&#39;</span><span class="p">);</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/fta&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_31_0.png" src="_images/11_31_0.png" />
</div>
</div>
<p>Notice the steps to set up the filter. We choose a bandpass filter <code class="docutils literal notranslate"><span class="pre">Wn</span></code>, which here is from 9–11 Hz. We choose this interval to focus on the LFP rhythm of largest amplitude (<span class="math notranslate nohighlight">\(\approx 10\)</span> Hz), which we identified through visual inspection<a href="#fig:LFP_ex" class="sup">fig<img src="imgs/lfp_ex.png"></a>. For each trial, we apply the filter to the LFP and then use the Hilbert transform (<code class="docutils literal notranslate"><span class="pre">signal.hilbert</span></code>) to estimate the phase. Finally, we sort this phase and use the sorted indices to arrange the spikes and store the results. We show the FTA averaged across all trials in the <a src="#fig:FTA" class="fig">figure above<img src="imgs/fta.png"></a>. In this case, no modulation in the number of spikes is apparent across trials. Instead, the number of spikes at each phase appears equally likely.</p>
<p>We may apply the FTA analysis to different frequency intervals of the LFP. Choosing a frequency interval may be motivated by our knowledge of the neural system generating the activity or by inspection of the field and spiking data.</p>
<div class="question">
<p><strong>Q.</strong> Investigate different frequency bands in the FTA analysis. Do you observe any interesting features?<br></p>
<p><em>Hint</em>: Consider frequencies near 45 Hz.</p>
</div><p>One final note about the FTA. The purpose of this measure is visualization, not statistical testing. Hopefully, this visual inspection will provide some insight into the data and guide continuing studies in promising directions. In what follows, we consider approaches to test for significant effects when we build a generalized linear model (GLM) to assess spike-field relations.</p>
</div>
<div class="section" id="spike-field-coherence-a-id-sec-spike-field-coherence-a">
<h2>Spike-field coherence <a id="sec:spike-field-coherence"></a><a class="headerlink" href="#spike-field-coherence-a-id-sec-spike-field-coherence-a" title="Permalink to this headline">¶</a></h2>
<p>To characterize the relation between the LFP and spikes, we have so far visualized the data and computed relatively simple and intuitive aids to visualization. Now we examine a more sophisticated and powerful method: the <strong>spike-field coherence</strong>. It’s common to investigate the coherence  applied to field activity; we may refer to this type of coherence as field-field coherence to distinguish it from spike-field coherence of interest here. In practice, this distinction is usually unnecessary, as in most cases the context is clear. However, in this module, we are careful to distinguish field-field coherence from spike-field coherence.</p>
<p>The field-field coherence is a frequency domain measure of linear association between two continuous time series. Note that, in practice, we observe a sampled version of a presumably continuous signal. This sampling impacts aspects of our data analysis, for example spectral estimators (see <a class="reference internal" href="03.html"><span class="doc">The Power Spectrum (Part 1)</span></a>). We showed in <a class="reference internal" href="05.html"><span class="doc">The Cross Covariance and Coherence</span></a> that two fields are coherent across trials at frequency <span class="math notranslate nohighlight">\(f_0\)</span> if the fields possess a constant phase relation across trials at that frequency. The same relation holds for the spike-field coherence. However, differences arise because of the point process nature of the spike train data. These differences have profound implications with dangerous consequences. In this module, we explore some of these issues. For a deeper mathematical discussion and potential solutions, see <a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a> and <a class="reference external" href="https://doi.org/10.1016/j.jneumeth.2012.10.010">Lepage et al, 2013</a>.</p>
<div class="section" id="mathematical-description-of-spike-field-coherence">
<h3>Mathematical description of spike-field coherence<a class="headerlink" href="#mathematical-description-of-spike-field-coherence" title="Permalink to this headline">¶</a></h3>
<p>Let’s begin with a mathematical description of the spike-field coherence. To do so, we need to introduce some notation, which is identical to that used in earlier modules, but we include it here for completeness. A more detailed description may be found in <a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a>.</p>
<p>We considered spectral estimators for a field in <a class="reference internal" href="03.html"><span class="doc">The Power Spectrum (Part 1)</span></a> and for a point process in <a class="reference internal" href="10.html"><span class="doc">Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</span></a>. We restate the Fourier transform for a time series <span class="math notranslate nohighlight">\(x\)</span>,</p>
<div class="math notranslate nohighlight">
\[
X_j = \sum_{n=1}^N x_n \exp(-2 \pi i \, f_j \, t_n)
\]</div>
<p>where <span class="math notranslate nohighlight">\(x_n\)</span> is the signal at time index <span class="math notranslate nohighlight">\(t_n = dt \{1, 2, 3, . . . N\}\)</span>, with sampling interval <span class="math notranslate nohighlight">\(dt\)</span>, and the frequencies <span class="math notranslate nohighlight">\(f_j = j/T\)</span>, where <span class="math notranslate nohighlight">\(j=\{-N/2+1, -N/2+2, \ldots , N/2-1, N/2\}\)</span>.  The spectral density of the time series is then,</p>
<div class="math notranslate nohighlight">
\[
S_{xx,j} = \frac{2 dt^2}{T} X_j X^*_j .
\]</div>
<p>Here, the time series can be either a field (i.e., the LFP) or a point process (i.e., the spike train).  Notice that we employ the same mathematical formula to compute the  spectrum  for each time series.</p>
<div class="math-note">
<p>For the spike train data, we first subtract the mean or expected number of spikes in each time interval and then apply the Fourier transform. In other words, the signal is the <em>centered increments</em> (see <a class="reference internal" href="10.html"><span class="doc">Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</span></a>).</p>
</div><p>Then, to estimate the coherence between two time series <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, <a id="eq:field-field-coherence"></a></p>
<div class="math notranslate nohighlight">
\[
\kappa_{xy,j} = \frac{ \mid &lt;S_{xy,j}&gt; \mid }{ \sqrt{&lt;S_{xx,j}&gt;} \sqrt{&lt;S_{yy,j}&gt;}}
\label{eq:SF_k0}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mid &lt;S_{xy,j}&gt; \mid\)</span> indicates the magnitude of the trial averaged cross spectrum, and <span class="math notranslate nohighlight">\(\mid &lt;S_{xx,j}&gt; \mid\)</span> and <span class="math notranslate nohighlight">\(\mid &lt;S_{yy,j}&gt; \mid\)</span> indicate the magnitude of the trial averaged spectra of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, respectively.  So far, there’s nothing new here;  we’ve just restated the standard expressions for the spectrum and coherence.  To compute the spike-field cohernece, we simply interpret one of the time series as a point process.  To make this more obvious in our mathematical expression, we replace <span class="math notranslate nohighlight">\(x\)</span> in the equation above with the symbol <span class="math notranslate nohighlight">\(n\)</span>, as a reminder that this time series represents the “number” of spikes,</p>
<div class="math notranslate nohighlight">
\[
\kappa_{ny,j} = \frac{ \mid &lt;S_{ny,j}&gt; \mid }{ \sqrt{&lt;S_{nn,j}&gt;} \sqrt{&lt;S_{yy,j}&gt;}}
\label{eq:SF_k}
\]</div>
<p>In the equation above, the numerator is now the magnitude of the trial averaged cross spectrum between the field <span class="math notranslate nohighlight">\(y\)</span> and spikes <span class="math notranslate nohighlight">\(n\)</span>, and the denominator contains the trial averaged spectrum of the spike <span class="math notranslate nohighlight">\(n\)</span> and the trial averaged spectrum of the field <span class="math notranslate nohighlight">\(y\)</span>.</p>
<div class="math-note">
<p>We could instead write the <em>sample</em> coherence, because this equation uses the observed data to estimate the theoretical coherence that we would see if we were to keep repeating this experiment. This distinction is not essential to our goals here, but is important when talking to your statistics-minded colleagues. Throughout this module and others, we omit the term “sample” when referring to sample means, variances, covariances, spectra, and so forth, unless this distinction becomes essential to our discussion.</p>
</div></div>
<div class="section" id="computing-the-spike-field-coherence-in-python">
<h3>Computing the Spike-Field-Coherence in Python.<a class="headerlink" href="#computing-the-spike-field-coherence-in-python" title="Permalink to this headline">¶</a></h3>
<p>As discussed in other modules (<a class="reference internal" href="03.html"><span class="doc">The Power Spectrum (Part 1)</span></a> and <a class="reference internal" href="10.html"><span class="doc">Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</span></a>), many issues are involved in spectral analysis, for example, the notions of tapering. These important issues apply for the computation of spike-field coherence as well. In practice, multitaper methods are often used to compute the spike-field coherence. In what follows, we simply a simple tapering approach to the field data.</p>
<p>Let’s now compute the spike-field coherence for the data of interest here. It’s relatively straightforward to do so in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SYY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>                                       <span class="c1"># Variable to store field spectrum.</span>
<span class="n">SNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>                                       <span class="c1"># Variable to store spike spectrum.</span>
<span class="n">SYN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>                        <span class="c1"># Variable to store cross spectrum.</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>                                           <span class="c1"># For each trial,</span>
    <span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]))</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>    <span class="c1"># Hanning taper the field,</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:])))</span>                   <span class="c1"># ... but do not taper the spikes.</span>
    <span class="n">SYY</span> <span class="o">=</span> <span class="n">SYY</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Field spectrum</span>
    <span class="n">SNN</span> <span class="o">=</span> <span class="n">SNN</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">nf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Spike spectrum</span>
    <span class="n">SYN</span> <span class="o">=</span> <span class="n">SYN</span> <span class="o">+</span> <span class="p">(</span>          <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span>   <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Cross spectrum</span>

<span class="n">cohr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">SYN</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">SYN</span><span class="p">))</span> <span class="o">/</span> <span class="n">SYY</span> <span class="o">/</span> <span class="n">SNN</span>                     <span class="c1"># Coherence</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>                                       <span class="c1"># Frequency axis for plotting</span>
</pre></div>
</div>
</div>
</div>
<p>Inside of the <code class="docutils literal notranslate"><span class="pre">for</span></code> statement, we first compute the Fourier transform of the field (<code class="docutils literal notranslate"><span class="pre">yf</span></code>) and the spikes (<code class="docutils literal notranslate"><span class="pre">nf</span></code>) for trial <code class="docutils literal notranslate"><span class="pre">k</span></code>. Notice that we subtract the mean from each signal before computing the Fourier transform, and that we apply a Hanning taper to the field data. We estimate the spectra for the field (<code class="docutils literal notranslate"><span class="pre">SYY</span></code>) and the spikes (<code class="docutils literal notranslate"><span class="pre">SNN</span></code>), and the cross spectrum (<code class="docutils literal notranslate"><span class="pre">SYN</span></code>) averaged across all trials. We then compute the coherence (<code class="docutils literal notranslate"><span class="pre">cohr</span></code>) and define a frequency axis to plot the results (<code class="docutils literal notranslate"><span class="pre">f</span></code>).</p>
<p>Let’s now display the results, <a id="fig:spike-field-coherence"></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># Plot the spike spectrum.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">SNN</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [Hz]&#39;</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s1">&#39;SNN&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>         <span class="c1"># Plot the field spectrum,</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span><span class="o">*</span><span class="n">SYY</span><span class="p">)</span>        <span class="c1"># ... with the standard scaling.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power [Hz]&#39;</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s1">&#39;SYY&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>        <span class="c1"># Plot the coherence</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">);</span>
<span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;imgs/sf_coh&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_45_0.png" src="_images/11_45_0.png" />
</div>
</div>
<div class="alert alert-block alert-info">
<p><strong>Q:</strong> Consider the spike spectrum, <code class="docutils literal notranslate"><span class="pre">Snn</span></code>, plotted in the figure above. What are the dominant rhythms? At frequencies beyond these dominant rhythms, the spectrum appears to fluctuate around a constant value. What is this constant value?</p>
<p><strong>A.</strong> To answer the first question, we determine through visual inspection of the figure that the dominant rhythm (i.e., the frequency with the most power) occurs at 10 Hz. We also note the presence of a second peak near 45 Hz.<br></p>
<p>To answer the second question, we note that the spike spectrum asymptotes at the expected spike rate (see [MODULE](add ref)). For these data, we can estimate the expected spike rate as</p>
<p><code class="docutils literal notranslate"><span class="pre">firing_rate</span> <span class="pre">=</span> <span class="pre">np.mean(np.sum(n,1))/(N*dt)</span></code></p>
<p>Computing this quantity in Python, we find an expected spike rate of approximately 89 Hz, consistent with the high-frequency behavior of <code class="docutils literal notranslate"><span class="pre">Snn</span></code> plotted in the figure.</p>
</div><div class="question">
<p><strong>Q:</strong> Consider the field spectrum, <code class="docutils literal notranslate"><span class="pre">Syy</span></code>, plotted in the figure above. What are the dominant rhythms? Do you observe any other interesting features in this spectrum?</p>
<p><strong>A:</strong> Visual inspection of the figure reveals that the dominant rhythm occurs at 10 Hz. At first glance, no additional spectral features stand out.</p>
</div><p>These observations of the spike spectrum and field spectrum reveal that both signals exhibit rhythmic activity at 10 Hz. Therefore, a reasonable place to look for spike-field coherence is near 10 Hz, where both the spikes and the field are rhythmic. However, visual inspection of the spike-field coherence does not indicate coherence at this frequency. Instead, we find a large peak in the spike-field coherence at 45 Hz. Identifying this strong coherence at 45 Hz suggests that we reexamine the spectra. Indeed, careful inspection of the spike spectrum and field spectrum does suggest rhythmic activity at 45 Hz.</p>
<div class="alert alert-block alert-info">
<p><strong>Q:</strong> Consider the field spectrum on a decibel scale (see <a class="reference internal" href="03.html"><span class="doc">The Power Spectrum (Part 1)</span></a>). What rhythms do you observe?</p>
</div><div class="question">
<p><strong>Q:</strong> Compare the results of your spike-field coherence analysis with the FTA plotted in <a class="reference external" href="#fig:FTA">this figure</a>. How does the peak in the spike-field coherence relate to interesting structure in the FTA?</p>
<div><p>The spike-field coherence result again reveals an important feature of coherence analysis. Two signals with high power at the same frequency are not necessarily coherent at this frequency; two signals may possess rhythmic activity at the same frequency, but these rhythms may not coordinate across trials. Conversely, two signals with low power at the same frequency may have strong coherence at that frequency; although the rhythm is weak, the two signals may still coordinate activity across trials at this frequency. These notions apply both to spike-field coherence and field-field coherence (the latter illustrated in <a class="reference internal" href="05.html"><span class="doc">The Cross Covariance and Coherence</span></a>).</p>
<p>The spike-field coherence is a powerful tool in our data analysis arsenal. There’s much more to say about this approach, and interested readers are directed to <a class="reference external" href="https://doi.org/10.1162/089976601300014312">Jarvis and Mitra, 2001</a>, <a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a> and <a class="reference external" href="https://doi.org/10.1016/j.jneumeth.2012.10.010">Lepage et al, 2013</a>.</p>
</div>
<div class="section" id="the-impact-of-firing-rate-on-the-spike-field-coherence">
<h3>The Impact of Firing Rate on the Spike-Field Coherence<a class="headerlink" href="#the-impact-of-firing-rate-on-the-spike-field-coherence" title="Permalink to this headline">¶</a></h3>
<p>Often, in the analysis of neural data, we compare the coherence between two pairs of signals. For example, in analysis of scalp EEG data, we might compare the coherence between voltage activity recorded at electrodes A and B with the coherence between voltage activity recorded at electrodes A and C. If we find that electrodes A and B have higher coherence at some frequency than electrodes A and C, we may conclude that the two brain regions A and B coordinate more strongly at this frequency. In this thought experiment, we are comparing the field-field coherence, which is not affected by the amplitude of the signals. For example, if we multiply the amplitude of signal C by a factor of 0.1, the field-field coherence does not change. To gain some intuition for this result, note that in the computation of the coherence<a href="#eq:field-field-coherence" class="sup">eq<img src="imgs/eq-ff_coh.png"></a>, we divide by the spectrum of each signal. In this way, a multiplicative change in signal amplitude appears in the numerator and denominator of the coherence formula and therefore (in this case) factors out.</p>
<p>We might expect the same for spike-field coherence. To test this, let’s manipulate the experimental data provided by our collaborator. Let’s begin by scaling the field data by a factor of 0.1, and recompute the spike-field coherence. Scaling the field data is easy to do in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_scaled</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">y</span>
</pre></div>
</div>
</div>
</div>
<p>With this change in the LFP data (<code class="docutils literal notranslate"><span class="pre">y</span></code>), we now recompute the spike-field coherence. To do so, let’s first define a function to compute the spike-field coherence,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">coherence</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>                           <span class="c1">#INPUT (spikes, fields, time)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                          <span class="c1">#... where spikes and fields are arrays [trials, time]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">SYY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">SNN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">SYN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:]))</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>    <span class="c1"># Hanning taper the field,</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:])))</span>                   <span class="c1"># ... but do not taper the spikes.</span>
        <span class="n">SYY</span> <span class="o">=</span> <span class="n">SYY</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Field spectrum</span>
        <span class="n">SNN</span> <span class="o">=</span> <span class="n">SNN</span> <span class="o">+</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">nf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Spike spectrum</span>
        <span class="n">SYN</span> <span class="o">=</span> <span class="n">SYN</span> <span class="o">+</span> <span class="p">(</span>          <span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">nf</span><span class="p">)</span>   <span class="p">)</span><span class="o">/</span><span class="n">K</span>                  <span class="c1"># Cross spectrum</span>

    <span class="n">cohr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">SYN</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">SYN</span><span class="p">))</span> <span class="o">/</span> <span class="n">SYY</span> <span class="o">/</span> <span class="n">SNN</span>                     <span class="c1"># Coherence</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>                                       <span class="c1"># Frequency axis for plotting</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">cohr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">SYY</span><span class="p">,</span> <span class="n">SNN</span><span class="p">,</span> <span class="n">SYN</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, with the fucntion <code class="docutils literal notranslate"><span class="pre">coherence</span></code> defined, let’s examine how a multiplicative change in the field <code class="docutils literal notranslate"><span class="pre">y</span></code> impacts the spike-field coherence,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">cohr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">SYY</span><span class="p">,</span> <span class="n">SNN</span><span class="p">,</span> <span class="n">SYN</span><span class="p">]</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>             <span class="c1"># Compute spike-field cohernece with original y.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="p">[</span><span class="n">cohr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">SYY</span><span class="p">,</span> <span class="n">SNN</span><span class="p">,</span> <span class="n">SYN</span><span class="p">]</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">y_scaled</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>      <span class="c1"># Compute spike-field cohernece with scaled y.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">,</span><span class="s1">&#39;.&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_57_0.png" src="_images/11_57_0.png" />
</div>
</div>
<p>We find that this multiplicative change in the amplitude of the field data does not impact the spike-field coherence. This result is consistent with our intuition from field-field coherence; the height of the field does not matter. Instead, it’s the consistency of the phase relation between two signals across trials that is critical for establishing the coherence.</p>
</div>
<div class="section" id="thinning-the-spike-train-a-id-sec-thin-a">
<h3>Thinning the spike train <a id="sec:thin"></a><a class="headerlink" href="#thinning-the-spike-train-a-id-sec-thin-a" title="Permalink to this headline">¶</a></h3>
<p>Now, let’s consider manipulating the spiking data. Right away, we notice a difference compared to the field data. In this case, a direct multiplicative change of the spiking data does not make sense. For example, consider multiplying the spike train data (<code class="docutils literal notranslate"><span class="pre">n</span></code>) by a factor of 0.1. Recall that the spike train data consist of two values: 0 or 1. Therefore, the new data after the scaling consist of two values: {0, 0.1} and the interpretation of the variable <code class="docutils literal notranslate"><span class="pre">n</span></code> no longer makes sense. What does it mean to have 0.1 spikes in a time interval?</p>
<p>Instead, to scale the spiking data, we change the average firing rate. We do so in a particular way: by removing spikes from the data, a process we refer to as <strong>thinning</strong>. The <a class="reference external" href="https://dx.doi.org/10.1016%2Fj.jneumeth.2012.10.010">process of thinning</a> is useful when comparing the spike-field coherence computed for two neurons with different firing rates. A reasonable, intuitive worry is that the firing rate of a neuron will impact the spike-field coherence. For example, we might consider that a neuron with a higher firing rate has the advantage of more opportunities to align with the field and therefore necessarily will possess a larger spike-field coherence. By thinning, we reduce the higher firing rate and establish the two neurons on an equal footing, both with the same opportunity to align with the field. The objective of the thinning procedure is to eliminate the contribution of firing rate differences to the spike-field coherence and allow direct comparison of spike-field coherence results computed for different neurons.</p>
<p>Let’s now thin the spiking data. Here, we implement a simple procedure by randomly selecting and removing spikes from each trial of the spiking data. We assume that in selecting spikes at random to remove, we eliminate both spikes phase-locked to the field and spikes independent of the field. In this way, neither spikes coupled to the LFP nor spikes independent of the LFP receive preferential treatment in the thinning procedure. So, any relations that exist between the spikes and the field are presumably preserved, and we might expect this thinning procedure, on its own, to not affect the spike-field coherence. Let’s define a function to implement this thinning procedure in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">thinned_spike_train</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">thinning_factor</span><span class="p">):</span>              <span class="c1"># Thin the spike train (n) by the thinning_factor.</span>
    <span class="n">n_thinned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>                                <span class="c1"># Make a copy of the spike train data.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>                                <span class="c1"># For each trial,</span>
        <span class="n">spike_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>                 <span class="c1"># ...find the spikes.</span>
        <span class="n">n_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>                   <span class="c1"># ...determine number of spikes.</span>
        <span class="n">spike_times_random</span> <span class="o">=</span> <span class="n">spike_times</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_spikes</span><span class="p">)]</span>    <span class="c1"># ...permute spikes indices,</span>
        <span class="n">n_remove</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">thinning_factor</span><span class="o">*</span><span class="n">n_spikes</span><span class="p">))</span>  <span class="c1"># ... determine number of spikes to remove,</span>
        <span class="n">n_thinned</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">spike_times_random</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_remove</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="mi">0</span>   <span class="c1"># remove the spikes.</span>
    <span class="k">return</span> <span class="n">n_thinned</span>
</pre></div>
</div>
</div>
</div>
<p>Note that within the <code class="docutils literal notranslate"><span class="pre">for-loop</span></code>, we first find the indices corresponding to spikes in trial <code class="docutils literal notranslate"><span class="pre">k</span></code>. We then randomly permute these indices, and select the appropriate proportion of these indices for removal.</p>
<p>Let’s apply this thinning procedure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">cohr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">SYY</span><span class="p">,</span> <span class="n">SNN</span><span class="p">,</span> <span class="n">SYN</span><span class="p">]</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>                          <span class="c1"># Plot the coherence for original spike train.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">)</span>
<span class="p">[</span><span class="n">cohr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">SYY</span><span class="p">,</span> <span class="n">SNN</span><span class="p">,</span> <span class="n">SYN</span><span class="p">]</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span><span class="n">thinned_spike_train</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span><span class="n">y</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="c1"># ... and for the thinned spike train.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">cohr</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">35</span><span class="p">,</span> <span class="mi">55</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_62_0.png" src="_images/11_62_0.png" />
</div>
</div>
<p>We  plot in the figure above the spike-field coherence for two different levels of thinning, one of which corresponds to the choice of a thinning factor of 0.5. We find that, for the thinned spike train, the peak of spike-field coherence decreases. Why? Intuition suggests that removing spikes at random (i.e., removing spikes coupled to the phase of LFP and removing spikes independent of the LFP) should preserve the spike-field coherence. Perhaps we were unlucky in the thinning procedure and selected to remove more phase-locked spikes than non-phase-locked spikes?</p>
<div class="question">
<p><strong>Q.</strong> Repeat the analysis with <code class="docutils literal notranslate"><span class="pre">thinning_factor</span> <span class="pre">=</span> <span class="pre">0.5</span></code> to select another random batch of spikes to remove. How does the spike-field coherence change compared to the original spike train data? Try this a couple of times, and investigate the peak spike-field coherence at 45 Hz. Is the peak in the spike-field coherence always reduced upon thinning?</p>
</div><p>Repeating the thinning procedure and selecting new instances of random spikes to remove preserves the qualitative result. The peak spike-field coherence at 45 Hz decreases. Perhaps we made a conceptual error in the thinning procedure or an error in the Python code? In fact, this result is not a numerical artifact or an error in the code or a problem with the estimate; it’s a property of the spike-field coherence. In <a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a> it’s proven that the spike-field coherence depends on the firing rate. An important result from <a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a> is:</p>
<div class="math-note">
<p>As the firing rate tends to zero, so does the spike-field coherence.</p>
</div><p>Therefore, we must be very careful when interpreting the spike-field coherence, especially when comparing the spike-field coherence of two neurons with different firing rates. A reduction in spike-field coherence may occur either through a reduction in association between the spikes and the field, or through a reduction in the firing rate with no change in association between the spikes and the field. This is an important and perhaps counter-intuitive result of spike-field coherence. Some procedures exist to mitigate the dependence of spike-field coherence on the firing rate, as discussed in the next section.</p>
<div class="math-note">
<p>Spike-field coherence responds to overall neural spiking activity, making comparisons between two pairs of spike-field time series difficult when the average spike-rate differs in the two spike-field pairs (<a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a>).</p>
</div></div>
</div>
<div class="section" id="point-process-models-of-the-spike-field-coherence-a-id-sec-point-process-model-a">
<h2>Point Process Models of the Spike-Field Coherence<a id="sec:point-process-model"></a><a class="headerlink" href="#point-process-models-of-the-spike-field-coherence-a-id-sec-point-process-model-a" title="Permalink to this headline">¶</a></h2>
<p>A variety of techniques exist to address the impact of firing rate on the spike-field coherence. We have already outlined the thinning procedure, a transformation-based technique in which the firing rates of two neurons are made equal by randomly removing spikes. Here, we focus on an additional technique that utilizes the generalized linear modeling (GLM) framework. We choose this technique (described in detail in <a class="reference external" href="https://doi.org/10.1016/j.jneumeth.2012.10.010">Lepage et al, 2013</a>) because it allows us to utilize the GLM framework (see <a class="reference internal" href="09.html"><span class="doc">Modeling place Fields with Point Process Generalized Linear Models</span></a> and <a class="reference internal" href="10.html"><span class="doc">Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</span></a>). The fundamental idea of this procedure is to model the conditional intensity of the point process as a function of the LFP phase. More specifically, we consider the model<a id="eq:glm"></a>:</p>
<div class="math notranslate nohighlight">
\[
\lambda_t = e^{\beta_0 + \beta_1 \cos(\phi(t)) + \beta_2 \sin(\phi(t))} \, ,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi(t)\)</span> is the instantaneous phase of a narrowband signal in the LFP.  To compute the phase, we bandpass filter the LFP and apply the Hilbert transform, as described above in our computation of the field-triggered average (FTA).  Then, using the canonical log link, we fit the GLM to the spike train data to estimate the model parameters.  We note that the first parameter <span class="math notranslate nohighlight">\(\beta_0\)</span> accounts for the overall activity of the neuron, while the other two parameters <span class="math notranslate nohighlight">\(\beta_1\)</span> and <span class="math notranslate nohighlight">\(\beta_2\)</span> capture the association between the LFP phase and spiking activity.  In this way, the overall firing rate and the impact of the field on the spiking activity are separately modeled, which mitigates the impact of firing rate on the measure of spike-field association, as we’ll see in the next series of examples.</p>
<p>For the analysis of spike-field association, we select a small frequency band of interest, bandpass-filter the field data, and then estimate the phase; the procedures to do so are identical to those used to compute the <a class="reference external" href="#FTA">FTA</a>. Building from those steps, we now focus on the procedures to estimate the phase and GLM in Python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                     <span class="c1"># Define the sampling interval.</span>
<span class="n">fNQ</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span>                       <span class="c1"># Define Nyquist frequency.</span>
<span class="n">Wn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>                        <span class="c1"># Set the passband</span>
<span class="nb">ord</span>  <span class="o">=</span> <span class="mi">100</span>                         <span class="c1"># ...and filter order,</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="n">fNQ</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">);</span>

<span class="n">phi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>                <span class="c1"># Create variable to hold phase.</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>             <span class="c1"># For each trial,</span>
    <span class="n">Vlo</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>       <span class="c1"># ... apply the filter,</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">Vlo</span><span class="p">))</span>  <span class="c1"># ... and compute the phase.</span>

<span class="n">n_reshaped</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>                     <span class="c1"># Make a copy of the spike data.</span>
<span class="n">n_reshaped</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_reshaped</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># Convert spike matrix to vector.</span>
<span class="n">phi_reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>            <span class="c1"># Convert phase matrix to vector.</span>
                                              <span class="c1"># Create a matrix of predictors [1, cos(phi), sin(phi)]</span>
<span class="n">X</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">)])</span>
<span class="n">Y</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">n_reshaped</span><span class="p">])</span>     <span class="c1"># Create a vector of responses.</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">())</span>    <span class="c1"># Build the GLM model,</span>
<span class="n">res</span>   <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>                                 <span class="c1"># ... and fit it.</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the variable definitions and filter settings in the variable <code class="docutils literal notranslate"><span class="pre">b</span></code> are similar to the Python code used to compute the <a class="reference external" href="#FTA">FTA</a>. The difference is that we now store the phases in a matrix (variable <code class="docutils literal notranslate"><span class="pre">phi</span></code>) that we use in the GLM procedure. To fit the GLM, we first collect the spikes and phases across trials into vectors (<code class="docutils literal notranslate"><span class="pre">n_reshaped</span></code> and <code class="docutils literal notranslate"><span class="pre">phi_reshaped</span></code>). Then we define the predictors (<code class="docutils literal notranslate"><span class="pre">X</span></code>, which consist of a constant and functions of the phase) and the response (<code class="docutils literal notranslate"><span class="pre">Y</span></code>, the spikes) and build the model using the function <code class="docutils literal notranslate"><span class="pre">GLM</span></code> and fit the model by calling the function <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
<p>Let’s compare the GLM results to the FTA:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X_predict</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">)])</span>
<span class="n">Y_predict</span>   <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">X_predict</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="s1">&#39;False&#39;</span><span class="p">)</span>

<span class="n">Wn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>                                  <span class="c1">#Define the passband, here from 9-11 Hz.</span>
<span class="n">FTA</span><span class="p">,</span> <span class="n">phi_axis</span> <span class="o">=</span> <span class="n">FTA_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Wn</span><span class="p">)</span>       <span class="c1">#Compute the FTA.</span>

<span class="n">plot</span><span class="p">(</span><span class="n">phi_axis</span><span class="p">,</span> <span class="n">FTA</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">,</span> <span class="n">Y_predict</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">,</span> <span class="n">Y_predict</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(),</span> <span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Phase&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability of a spike&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_72_0.png" src="_images/11_72_0.png" />
</div>
</div>
<p>The modeling estimates are shown in the figure above: the FTA <a href="#fig:FTA" class="sup">fig<img src="imgs/fta.png"></a> and the estimates of the GLM (computed using the Python function <code class="docutils literal notranslate"><span class="pre">get_prediction</span></code>). The agreement is excellent. Notice for the 9–11 Hz frequency band the lack of modulation in the estimated conditional intensity, which suggests that the probability of spiking is not affected by the phase of the LFP in the 9–11 Hz frequency range.</p>
<p>Let’s now repeat this analysis but instead bandpass-filter the LFP data for 44–46 Hz; we choose this frequency interval motivated by the spike-field coherence results<a href="#fig:spike-field-coherence" class="sup">fig<img src="imgs/sf_coh.png"></a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span><span class="mi">46</span><span class="p">]</span>                       <span class="c1"># Set the passband</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">Wn</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="n">fNQ</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">);</span>

<span class="k">del</span> <span class="n">phi</span>
<span class="n">phi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>                <span class="c1"># Create variable to hold phase.</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>             <span class="c1"># For each trial,</span>
    <span class="n">Vlo</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>       <span class="c1"># ... apply the filter,</span>
    <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">Vlo</span><span class="p">))</span>  <span class="c1"># ... and compute the phase.</span>

<span class="n">n_reshaped</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">n_reshaped</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_reshaped</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Convert spike matrix to vector.</span>
<span class="n">phi_reshaped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># Convert phase matrix to vector.</span>
                                           <span class="c1"># Create a matrix of predictors [1, cos(phi), sin(phi)]</span>
<span class="n">X</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_reshaped</span><span class="p">)])</span>
<span class="n">Y</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">n_reshaped</span><span class="p">])</span>  <span class="c1"># Create a vector of responses.</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">())</span>    <span class="c1"># Build the GLM model,</span>
<span class="n">res</span>   <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>                                 <span class="c1"># ... and fit it,</span>

<span class="n">phi_predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>       <span class="c1"># ... and evaluate the model results.</span>
<span class="n">X_predict</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">)])</span>
<span class="n">Y_predict</span>   <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">X_predict</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="s1">&#39;False&#39;</span><span class="p">)</span>

<span class="n">FTA</span><span class="p">,</span> <span class="n">phi_axis</span> <span class="o">=</span> <span class="n">FTA_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Wn</span><span class="p">)</span>       <span class="c1">#Compute the FTA, in the new frequency interval</span>

<span class="n">plot</span><span class="p">(</span><span class="n">phi_axis</span><span class="p">,</span> <span class="n">FTA</span><span class="p">)</span>                          <span class="c1">#... and plot it, along with the model fit.</span>
<span class="n">plot</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">,</span> <span class="n">Y_predict</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">phi_predict</span><span class="p">,</span> <span class="n">Y_predict</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(),</span> <span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Phase&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability of a spike&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/11_74_0.png" src="_images/11_74_0.png" />
</div>
</div>
<p>Now, for this frequency interval, we find a modulation of the estimated conditional intensity, with an increase in the probability of a spike near 0 radians. These results illustrate the close correspondence between the FTA and GLM procedures. An important advantage of the GLM approach is the ability to estimate confidence intervals. The confidence intervals in the figure above are estimated in the <code class="docutils literal notranslate"><span class="pre">get_prediction</span></code> function and returned as the outputs <code class="docutils literal notranslate"><span class="pre">Y_predict.conf_int()</span></code>.</p>
<p>For the LFP data filtered at 44–46 Hz, let’s check the significance of the parameters related to the LFP phase, <span class="math notranslate nohighlight">\(\beta_1\)</span> and <span class="math notranslate nohighlight">\(\beta_2\)</span>, via a Wald test (see [MODULE](add ref)):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pval1</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>       <span class="c1">#Significance of parameter beta_1.</span>
<span class="n">pval2</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>       <span class="c1">#Significance of parameter beta_2.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pval1</span><span class="p">,</span> <span class="n">pval2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>1.484034529060339e-52 0.7187267797864678
</pre></div>
</div>
</div>
</div>
<p>We find that <span class="math notranslate nohighlight">\(\beta_1\)</span> is highly significant (<code class="docutils literal notranslate"><span class="pre">pval1=1.48e-52</span></code>) and <span class="math notranslate nohighlight">\(\beta_2\)</span> is not significant (<code class="docutils literal notranslate"><span class="pre">pval2=0.719</span></code>), and we conclude that the firing rate is highly dependent on the cosine of the LFP phase.</p>
<p>In <a class="reference internal" href="09.html"><span class="doc">Modeling place Fields with Point Process Generalized Linear Models</span></a>, we showed that for nested models (where one model can be made equivalent to the other by setting some parameters to specific values), under the null hypothesis that the data arise from the smaller model, the difference in the deviance between the two models should have a chi-square distribution where the number of degrees of freedom is equal to the number of extra parameters in the larger model. In this case, let’s compare the model<a href="#eq:glm" class="sup">eq<img src="imgs/eq-glm.png"></a> we originally designed to a model that lacks dependence on the LFP phase (i.e., a reduced model in which  <span class="math notranslate nohighlight">\(\beta_1\)</span> and <span class="math notranslate nohighlight">\(\beta_2\)</span> are set to zero). First, we must construct and estimate this reduced model. In Python,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>                               <span class="c1">#Define constant predictor.</span>
<span class="n">null_model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X0</span><span class="p">,</span><span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">())</span>  <span class="c1">#Define reduced model.</span>
<span class="n">null_res</span>   <span class="o">=</span> <span class="n">null_model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>                           <span class="c1">#Fit reduced model.</span>
</pre></div>
</div>
</div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">X0</span></code> is a constant predictor (consisting of all 1’s). Then, to
compute the p-value for this test in Python,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pval</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">null_res</span><span class="o">.</span><span class="n">deviance</span><span class="o">-</span><span class="n">res</span><span class="o">.</span><span class="n">deviance</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#Compare two nested GLMs.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>0.0
</pre></div>
</div>
</div>
</div>
<div class="question">
<p><strong>Q:</strong> Why do we set the second input to the function <code class="docutils literal notranslate"><span class="pre">stats.chi2.cdf</span></code> equal to 2?</p>
</div><p>We find <code class="docutils literal notranslate"><span class="pre">pval=0</span></code> and would therefore be very unlikely to see this result if the reduced model (i.e., the model lacking dependence on the LFP phase) were correct.</p>
<p>Finally, let’s examine how thinning the spiking data impacts the results of the GLM procedure. We choose a <a class="reference external" href="#sec:thin">thinning factors</a> of 0.5 and repeat the analysis for LFP filtered at 44–46 Hz to recompute the FTA and estimate the GLM model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_thinned_reshaped</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">thinned_spike_train</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Convert thinned spike matrix to vector.</span>
<span class="n">Y</span>                    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">n_thinned_reshaped</span><span class="p">])</span>          <span class="c1"># Create a vector of responses.</span>

<span class="n">thinned_model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">())</span>           <span class="c1"># Build the GLM model,</span>
<span class="n">res_thinned</span>   <span class="o">=</span> <span class="n">thinned_model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>                                <span class="c1"># ... and fit it.</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s now compare how the estimates of the exponentiated model parameters (<span class="math notranslate nohighlight">\(\beta_0\)</span>, <span class="math notranslate nohighlight">\(\beta_1\)</span>, and <span class="math notranslate nohighlight">\(\beta_2\)</span>) vary with the thinning factor. As the thinning factor increases, the probability of a spike decreases. This probability can be estimated from the spike train data <code class="docutils literal notranslate"><span class="pre">n</span></code> as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
</div>
<p>To compare how the thinning factor impacts the probability of a spike, let’s compute the expression above for the original spike train data (<code class="docutils literal notranslate"><span class="pre">n</span></code>) and the thinned spike train, and determine their ratio,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_thinned_reshaped</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_reshaped</span><span class="p">))</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>0.514420910319964
</pre></div>
</div>
</div>
</div>
<p>As expected the ratio of the probabilities is near 0.5, which is consistent with a thinning factor of 0.5.</p>
<p>Now, let’s compare the ratios of <span class="math notranslate nohighlight">\(\exp(\beta_0)\)</span> estimated for the two models</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res_thinned</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>0.5137925487970073
</pre></div>
</div>
</div>
</div>
<p>We find that this ratio is also near 0.5. We conclude that the two measures - the estimate of probability of a spike and <span class="math notranslate nohighlight">\(\exp(\beta_0)\)</span> - are in excellent agreement; as expected, as the thinning factor increases, the probability of a spike decreases.</p>
<p>Finally, let’s compare the exponentiated estimates of the other model parameters, <span class="math notranslate nohighlight">\(\beta_1\)</span> and <span class="math notranslate nohighlight">\(\beta_2\)</span>, for the original and thinned spike data. Recall that these parameters represent the impact of the LFP phase on the firing rate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res_thinned</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>  <span class="c1"># compare ratio of exp(beta_1)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res_thinned</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>  <span class="c1"># compare ratio of exp(beta_2)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[1.2737293264421767, 1.2604558073768586]
[0.9997475534029581, 0.9945940761801922]
</pre></div>
</div>
</div>
</div>
<p>There are two important features to notice about these estimates:</p>
<ul class="simple">
<li><p>First, the thinning factor does not affect these parameter estimates. The changing firing rate is captured in the parameter <span class="math notranslate nohighlight">\(\beta_0\)</span> and prevented from impacting the estimates of the spike-field association expressed in the other model parameters.</p></li>
<li><p>Second, the exponentiated parameter <span class="math notranslate nohighlight">\(\beta_1\)</span> is well above 1, which indicates a significant association between the cosine phase of the LFP in the 44–46 Hz frequency band and the spiking.</p></li>
</ul>
<p><a class="reference external" href="#top">Return to top</a></p>
<p><a id="summary"></a></p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this module, we considered associations between data recorded from different spatial scales: the macroscale LFP and the microscale spiking. We developed methods to visualize the associations between scales, and applied tools developed in other modules, such as the spectrum and coherence. We computed the spike-field coherence and found a strong association between the spatial scales near 45 Hz despite only the weak appearance of this rhythm in the spectra. We also considered the impact of firing rate on the spike-field coherence and illustrated that as the firing rate decreases, so does the spike-field coherence (<a class="reference external" href="https://doi.org/10.1162/NECO_a_00169">Lepage et al, 2011</a>).</p>
<p>To account for the impact of firing rate on coherence we implemented a GLM, in which the firing rate depends on the LFP phase. In general, GLMs provide a powerful tool to estimate spike-field associations. The example considered here illustrates the ability of the GLM framework to estimate the influence of the LFP phase on the spiking and avoid the confounding effect of a changing firing rate. For details describing this approach and its extensions, see (<a class="reference external" href="https://doi.org/10.1016/j.jneumeth.2012.10.010">Lepage et al, 2013</a>).</p>
</div>
</div>


              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="10.html" title="previous page">Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task</a>
    <a class='right-next' id="next-link" href="A01.html" title="next page">Backpropagation</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Mark Kramer and Uri Eden<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="_static/js/index.js"></script>
    
  </body>
</html>