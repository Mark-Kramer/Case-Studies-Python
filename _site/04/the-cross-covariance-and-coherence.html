<!DOCTYPE html>
<html lang="en">
  

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>The Cross Covariance and Coherence</title>
  <meta name="description" content="Analysis of coupled rhythms for the practicing neuroscientist">

  <link rel="canonical" href="https://eschlaf2.github.io/Case-Studies-Python/04/the-cross-covariance-and-coherence.html">
  <link rel="alternate" type="application/rss+xml" title="Case Studies in Neural Data Analysis" href="https://eschlaf2.github.io/Case-Studies-Python/feed.xml">

  <meta property="og:url"         content="https://eschlaf2.github.io/Case-Studies-Python/04/the-cross-covariance-and-coherence.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="The Cross Covariance and Coherence" />
<meta property="og:description" content="Analysis of coupled rhythms for the practicing neuroscientist" />
<meta property="og:image"       content="" />


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage":
    "https://eschlaf2.github.io/Case-Studies-Python/04/the-cross-covariance-and-coherence.html",
  "headline":
    "The Cross Covariance and Coherence",
  "datePublished":
    "2019-04-24T17:33:10-04:00",
  "dateModified":
    "2019-04-24T17:33:10-04:00",
  "description":
    "Analysis of coupled rhythms for the practicing neuroscientist",
  "author": {
    "@type": "Person",
    "name": "Mark Kramer and Uri Eden"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://eschlaf2.github.io/Case-Studies-Python",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://eschlaf2.github.io/Case-Studies-Python",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/Case-Studies-Python/assets/css/styles.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css ">
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/Case-Studies-Python/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    CommonHTML: {
        linebreaks: {
            automatic: true,
        },
    },
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML' async></script>

  <!-- DOM updating function -->
  <script>
const runWhenDOMLoaded = cb => {
  if (document.readyState != 'loading') {
    cb()
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', cb)
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') cb()
    })
  }
}

// Helper function to init things quickly
initFunction = function(myfunc) {
  runWhenDOMLoaded(myfunc);
  document.addEventListener('turbolinks:load', myfunc);
};
</script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/Case-Studies-Python';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="/Case-Studies-Python/assets/js/anchor.min.js"  type="text/javascript"></script>
  <script>

initFunction(function () {
    anchors.add("main h1, main h2, main h3, main h4")
});

</script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="/Case-Studies-Python/assets/js/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Load nbinteract for widgets -->
  <script src="https://unpkg.com/nbinteract-core" async></script>

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->

<script type="text/x-thebe-config">
    {
      requestKernel: true,
      binderOptions: {
        repo: 'eschlaf2/Case-Studies-Python',
        ref: 'master',
      },
      kernelOptions: {
        name: 'python3',
      }
    }
</script>
<script src="https://unpkg.com/thebelab@0.3.3/lib/index.js"></script>
<script>
    /**
     * Add attributes to Thebelab blocks
     */

    const initThebelab = () => {
        const addThebelabToCodeCells = () => {
            console.log("Adding thebelab to code cells...");
            // If Thebelab hasn't loaded, wait a bit and try again. This
            // happens because we load ClipboardJS asynchronously.
            if (window.thebelab === undefined) {
                setTimeout(addThebelabToCodeCells, 250)
            return
            }

            // If we already detect a Thebelab cell, don't re-run
            if (document.querySelectorAll('div.thebelab-cell').length > 0) {
                return;
            }

            // Find all code cells, replace with Thebelab interactive code cells
            const codeCells = document.querySelectorAll('.input_area pre')
            codeCells.forEach((codeCell, index) => {
                const id = codeCellId(index)
                codeCell.setAttribute('data-executable', 'true')

                // Figure out the language it uses and add this too
                var parentDiv = codeCell.parentElement.parentElement;
                var arrayLength = parentDiv.classList.length;
                for (var ii = 0; ii < arrayLength; ii++) {
                    var parts = parentDiv.classList[ii].split('language-');
                    if (parts.length === 2) {
                        // If found, assign dataLanguage and break the loop
                        var dataLanguage = parts[1];
                        break;
                    }
                }
                codeCell.setAttribute('data-language', dataLanguage)

                // If the code cell is hidden, show it
                var inputCheckbox = document.querySelector(`input#hidebtn${codeCell.id}`);
                if (inputCheckbox !== null) {
                    setCodeCellVisibility(inputCheckbox, 'visible');
                }
            });

            // Remove the event listener from the page so keyboard press doesn't
            // Change page
            document.removeEventListener('keydown', initPageNav)
            keyboardListener = false;

            // Init thebelab
            thebelab.bootstrap();

            // Remove copy buttons since they won't work anymore
            const copyButtons = document.querySelectorAll('.copybtn')
            copyButtons.forEach((copyButton, index) => {
                copyButton.remove();
            });

            // Remove outputs since they'll be stale
            const outputs = document.querySelectorAll('.output *, .output')
            outputs.forEach((output, index) => {
                output.remove();
            });
        }

        // Add event listener for the function to modify code cells
        const thebelabButton = document.getElementById('interact-button-thebelab');
        if (thebelabButton === null) {
            setTimeout(initThebelab, 250)
        return
        };
        thebelabButton.addEventListener('click', addThebelabToCodeCells);
    }

    // Initialize Thebelab
    initFunction(initThebelab);
</script>


  <!-- Google analytics -->
  <script src="/Case-Studies-Python/assets/js/ga.js" async></script>

  <!-- Clipboard copy button -->
  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" async></script>

  <!-- Load JS that depends on site variables -->
  <script>
/**
 * Set up copy/paste for code blocks
 */
const codeCellId = index => `codecell${index}`

const clipboardButton = id =>
  `<a class="btn copybtn o-tooltip--left" data-tooltip="Copy" data-clipboard-target="#${id}">
    <img src="/Case-Studies-Python/assets/images/copy-button.svg" alt="Copy to clipboard">
  </a>`

// Clears selected text since ClipboardJS will select the text when copying
const clearSelection = () => {
  if (window.getSelection) {
    window.getSelection().removeAllRanges()
  } else if (document.selection) {
    document.selection.empty()
  }
}

// Changes tooltip text for two seconds, then changes it back
const temporarilyChangeTooltip = (el, newText) => {
  const oldText = el.getAttribute('data-tooltip')
  el.setAttribute('data-tooltip', newText)
  setTimeout(() => el.setAttribute('data-tooltip', oldText), 2000)
}

const addCopyButtonToCodeCells = () => {
  // If ClipboardJS hasn't loaded, wait a bit and try again. This
  // happens because we load ClipboardJS asynchronously.
  if (window.ClipboardJS === undefined) {
    setTimeout(addCopyButtonToCodeCells, 250)
    return
  }

  const codeCells = document.querySelectorAll('div.highlighter-rouge:not(.output) pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.querySelector(`pre#${id} + a`) == null) {
      codeCell.insertAdjacentHTML('afterend', clipboardButton(id));
    }
  })

  const clipboard = new ClipboardJS('.copybtn')
  clipboard.on('success', event => {
    clearSelection()
    temporarilyChangeTooltip(event.trigger, 'Copied!')
  })

  clipboard.on('error', event => {
    temporarilyChangeTooltip(event.trigger, 'Failed to copy')
  })

  // Get rid of clipboard before the next page visit to avoid memory leak
  document.addEventListener('turbolinks:before-visit', () =>
    clipboard.destroy()
  )
}

initFunction(addCopyButtonToCodeCells);
</script>

  <!-- Hide cell code -->
  
<script>
/**
Add buttons to hide code cells
*/


var setCodeCellVisibility = function(inputField, kind) {
    // Update the image and class for hidden
    var id = inputField.getAttribute('data-id');
    var codeCell = document.querySelector(`#${id}`);

    if (kind === "visible") {
        codeCell.classList.remove('hidden');
        inputField.checked = true;
    } else {
        codeCell.classList.add('hidden');
        inputField.checked = false;
    }
}

var toggleCodeCellVisibility = function (event) {
    // The label is clicked, and now we decide what to do based on the input field's clicked status
    if (event.target.tagName === "LABEL") {
        var inputField = event.target.previousElementSibling;
    } else {
        // It is the span inside the target
        var inputField = event.target.parentElement.previousElementSibling;
    }

    if (inputField.checked === true) {
        setCodeCellVisibility(inputField, "visible");
    } else {
        setCodeCellVisibility(inputField, "hidden");
    }
}


// Button constructor
const hideCodeButton = id => `<input class="hidebtn" type="checkbox" id="hidebtn${id}" data-id="${id}"><label title="Toggle cell" for="hidebtn${id}" class="plusminus"><span class="pm_h"></span><span class="pm_v"></span></label>`

var addHideButton = function () {
  // If a hide button is already added, don't add another
  if (document.querySelector('div.hidecode input') !== null) {
      return;
  }

  // Find the input cells and add a hide button
  document.querySelectorAll('div.input_area div.highlight').forEach(function (item, index) {
    if (!item.parentElement.classList.contains("hidecode")) {
        // Skip the cell if it doesn't have a hidecode class
        return;
    }

    const id = codeCellId(index)
    item.setAttribute('id', id);
    item.insertAdjacentHTML('afterend', hideCodeButton(id))

    // Set up the visibility toggle
    hideLink = document.querySelector(`#${id} + input + label`);
    hideLink.addEventListener('click', toggleCodeCellVisibility)
  });
}


// Initialize the hide buttos
var initHiddenCells = function () {
    // Add hide buttons to the cells
    addHideButton();

    // Toggle the code cells that should be hidden
    document.querySelectorAll('div.hidecode input').forEach(function (item) {
        setCodeCellVisibility(item, 'hidden');
        item.checked = true;
    })
}

initFunction(initHiddenCells);

</script>


  <!-- Load custom website scripts -->
  <script src="/Case-Studies-Python/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/Case-Studies-Python/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/Case-Studies-Python/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  
<script>
/**
  * To auto-embed hub URLs in interact links if given in a RESTful fashion
 */

function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
    
function dict2param(dict) {
    params = Object.keys(dict).map(function(k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(dict[k])
    });
    return params.join('&')
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return dict2param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = document.querySelectorAll("a").forEach(function(link) {
    var href = link.href;
    // If the link is an internal link...
    if (href.search("https://eschlaf2.github.io") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['jupyterhub'] = hub;
      } else {
        // Create the REST params
        params = {'jupyterhub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + dict2param(params);
      link.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}


// Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    jupyterHubUrl = rest['jupyterhub'];
    var hubType = null;
    var hubUrl = null;
    if (jupyterHubUrl !== undefined) {
      hubType = 'jupyterhub';
      hubUrl = jupyterHubUrl;
    }

    if (hubType !== null) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);

      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      var interactButtons = document.querySelectorAll("button.interact-button")
      var lastButton = interactButtons[interactButtons.length-1];
      var link = lastButton.parentElement;

      // If we've already run this, skip the link updating
      if (link.nextElementSibling !== null) {
        return;
      }

      // Update the link and add context div
      var href = link.getAttribute('href');
      if (lastButton.id === 'interact-button-binder') {
        // If binder links exist, we need to re-work them for jupyterhub
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // If localhost, assume we're working from a local Jupyter server and remove `/hub`
          first = [hubUrl, 'git-sync'].join('/')
        } else {
          first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
        }
        href = first + '?' + binder2Jupyterhub(href);
      } else {
        // If interact button isn't binderhub, assume it's jupyterhub
        // If JupyterHub links, we only need to replace the hub url
        href = href.replace("", hubUrl);
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // Assume we're working from a local Jupyter server and remove `/hub`
          href = href.replace("/hub/user-redirect", "");
        }
      }
      link.setAttribute('href', decodeURIComponent(href));

      // Add text after interact link saying where we're launching
      hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
      link.insertAdjacentHTML('afterend', '<div class="interact-context">on ' + hubUrlNoHttp + '</div>');

      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

runWhenDOMLoaded(updateInteractLink)
document.addEventListener('turbolinks:load', updateInteractLink)
</script>


  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="/Case-Studies-Python/assets/js/lunr/lunr.min.js" type="text/javascript"></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>
</head>

  <body>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://jupyter.org/jupyter-book/intro.html"><img src="/Case-Studies-Python/images/logo/logo.png" class="textbook_logo" id="sidebar-logo" data-turbolinks-permanent/></a>
  <h2 class="c-sidebar__title">Case Studies in Neural Data Analysis</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/Case-Studies-Python/intro.html"
        >
          
          Home
        </a>

        
      </li>

      
    
      
      
        <li class="c-sidebar__chapter"><a class="c-sidebar__entry" href="/Case-Studies-Python/search.html">Search</a></li>
        
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="https://github.com/Mark-Kramer/Case-Studies-Python.git"
        >
          
          GitHub repository
        </a>

        
      </li>

      
    
      
      
        <li class="c-sidebar__divider"></li>
        
      
      
        <li><h2 class="c-sidebar__title">Contents</li>
        
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/Case-Studies-Python/01/Intro.html"
        >
          
            1.
          
          Introduction to Python
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/Case-Studies-Python/02/the-event-related-potential.html"
        >
          
            2.
          
          The Event-Related Potential
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/Case-Studies-Python/03/the-power-spectrum-part-1.html"
        >
          
            3.
          
          The Power Spectrum (Part 1)
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections u-hidden-visually">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/Case-Studies-Python/03/supplement-1.html"
                >
                  
                    3.1
                  
                  Biased versus unbiased autocovariance
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/Case-Studies-Python/03/supplement-2.html"
                >
                  
                    3.2
                  
                  Intuition behind the power spectral density
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry c-sidebar__entry--active"
          href="/Case-Studies-Python/04/the-cross-covariance-and-coherence.html"
        >
          
            4.
          
          The Cross Covariance and Coherence
        </a>

        
      </li>

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="https://github.com/jupyter/jupyter-book">Jupyter Book</a></p>
</nav>

      
      <!-- Shamelessly copied from minimal mistakes -->


<!-- TOC will only show up if it has at least one item -->


  <aside class="sidebar__right">
    <nav class="onthispage">
      <header><h4 class="nav__title"><i class="fa fa-list"></i>   On this page</h4></header>
      <ul class="toc__menu">
  <li><a href="#on-ramp-computing-the-coherence-in-python">On-ramp: computing the coherence in Python</a>
    <ul>
      <li><a href="#background-">Background </a></li>
      <li><a href="#case-study-data-">Case Study Data </a></li>
      <li><a href="#goal-">Goal </a></li>
      <li><a href="#tools">Tools</a></li>
    </ul>
  </li>
  <li><a href="#data-analysis-">Data Analysis </a>
    <ul>
      <li><a href="#visual-inspection-">Visual inspection </a></li>
      <li><a href="#autocovariance-and-cross-covariance-">Autocovariance and Cross-covariance </a></li>
      <li><a href="#trial-averaged-spectrum-">Trial-Averaged Spectrum </a></li>
    </ul>
  </li>
  <li><a href="#simple-scenario-1--phases-align-across-trials-">Simple Scenario 1:  Phases align across trials </a></li>
  <li><a href="#visualizing-the-phase-difference-across-trials-">Visualizing the Phase Difference across Trials </a></li>
  <li><a href="#single-trial-coherence-">Single-Trial Coherence </a></li>
  <li><a href="#relation-between-statistical-modeling-and-coherence-">Relation between Statistical Modeling and Coherence </a></li>
</ul>
    </nav>
  </aside>


      
      <main class="c-textbook__page" tabindex="-1">
          <div class="o-wrapper">
            <div class="c-sidebar-toggle">
  <!-- We show the sidebar by default so we use .is-active -->
  <button
    id="js-sidebar-toggle"
    class="hamburger hamburger--arrowalt is-active"
  >
    <span class="hamburger-box">
      <span class="hamburger-inner"></span>
    </span>
    <span class="c-sidebar-toggle__label">Toggle Sidebar</span>
  </button>
</div>

            
<div class="buttons">
<a href="/Case-Studies-Python/content/04/the-cross-covariance-and-coherence.ipynb" download>
<button id="interact-button-download" class="interact-button">Download</button>
</a>

<button id="interact-button-thebelab" class="interact-button">Thebelab</button>








<a href="https://mybinder.org/v2/gh/eschlaf2/Case-Studies-Python/master?filepath=content%2F04%2Fthe-cross-covariance-and-coherence.ipynb"><button class="interact-button" id="interact-button-binder"><img class="interact-button-logo" src="/Case-Studies-Python/assets/images/logo_binder.svg" alt="Interact" />Interact</button></a>


</div>


            <div class="c-textbook__content">
              <p><a id="introduction"></a></p>
<h1 id="analysis-of-coupled-rhythms-for-the-practicing-neuroscientist">Analysis of coupled rhythms <em>for the practicing neuroscientist</em></h1>

<div class="alert alert-block alert-info">
  <p><em><strong>Synopsis</strong></em> <br /><br /></p>

  <p><strong>Data:</strong> 1 s of ECoG data sampled at 500 Hz from two electrodes for 100 trials.<br /></p>

  <p><strong>Goal:</strong> Characterize the coupling of rhythmic activity between the two electrodes.<br /></p>

  <p><strong>Tools:</strong> Fourier transform, spectrum, amplitude, coherence, phase.</p>

</div>

<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#case-study-data">Case Study Data</a></li>
  <li><a href="#data-analysis">Data Analysis</a>
    <ul>
      <li><a href="#visual-inspection">Visual Inspection</a></li>
      <li><a href="#Autocovariance-and-Cross-covariance">Autocovariance and Cross-covariance</a></li>
      <li><a href="#Trial-Averaged-Spectrum">Trial-Averaged Spectrum</a></li>
    </ul>
  </li>
  <li><a href="#sec:coherence">Introduction to the Coherence</a>
    <ul>
      <li><a href="#Simple_Scenario_1">Simple Scenario 1: Phases align across trials</a></li>
      <li><a href="#Simple_Scenario_2">Simple Scenario 2: Phases are random across trials</a></li>
      <li><a href="#Summary_of_the_coherence">Summary of the coherence</a></li>
    </ul>
  </li>
  <li><a href="#cc_and_cs">Cross-Covariance and Cross-Spectrum</a></li>
  <li><a href="#computing_coherence">Computing the Coherence</a>
    <ul>
      <li><a href="#Visualizing_the_Phase_Difference">Visualizing the Phase Difference across Trials</a></li>
      <li><a href="#single_trial_coherence">Single-Trial Coherence</a></li>
    </ul>
  </li>
  <li><a href="#Relation_between_Statistical_Modeling_and_Coherence">Relation between Statistical Modeling and Coherence</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<h2 id="on-ramp-computing-the-coherence-in-python">On-ramp: computing the coherence in Python</h2>
<p>We begin this module with an “<em>on-ramp</em>” to analysis. The purpose of this on-ramp is to introduce you immediately to a core concept in this module: how to compute the coherence in Python. You may not understand all aspects of the program here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what <em>can</em> be done. Our advice is to simply run the code below and see what happens …</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="n">sio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'ECoG-1.mat'</span><span class="p">)</span>                  <span class="c"># Load the data,</span>
<span class="n">E1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'E1'</span><span class="p">]</span>                                   <span class="c"># ... from the first electrode,</span>
<span class="n">E2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'E2'</span><span class="p">]</span>                                   <span class="c"># ... and from the second electrode.</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'t'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>                                  <span class="c"># Load the time axis,</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>                                    <span class="c"># ... to get the sampling interval,</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>                                         <span class="c"># ... and the total time of the recording.</span>
<span class="n">K</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span>                                <span class="c"># Get the number of trials, and number of pts per trial.</span>

<span class="n">Sxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>		              <span class="c"># Create variables to save the spectra,</span>
<span class="n">Syy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="n">Sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>			                      <span class="c"># For each trial,</span>
    <span class="n">x</span><span class="o">=</span><span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>                    <span class="c"># ... get the data from each electrode,</span>
    <span class="n">y</span><span class="o">=</span><span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>
    <span class="n">xf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>               <span class="c"># ... compute Fourier transform,</span>
    <span class="n">yf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">Sxx</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">xf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">xf</span><span class="p">))</span> <span class="c"># ... and compute the spectra.</span>
    <span class="n">Syy</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">yf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">))</span>
    <span class="n">Sxy</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span> <span class="o">*</span>       <span class="p">(</span><span class="n">xf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">))</span>

<span class="n">Sxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>		                      <span class="c"># Average the spectra across trials,</span>
<span class="n">Syy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Syy</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Sxy</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="n">cohr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">Sxy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Syy</span><span class="p">))</span><span class="c"># ... and compute the coherence.</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>                        <span class="c"># Define a frequency axis.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">cohr</span><span class="p">);</span>		                          <span class="c"># Plot coherence vs frequency,</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>			                      <span class="c"># ... in a chosen frequency range,</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>                                  <span class="c"># ... with y-axis scaled,</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Frequency [Hz]'</span><span class="p">)</span>                      <span class="c"># ... and with axes labelled.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Coherence'</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Q:</strong> Try to read the code above. Can you see how it loads data, computes the coherence, and then plots the results?</p>

<p><strong>A:</strong> If you’ve never computed the coherence before, that’s an especially difficult question. Please continue on to learn this <strong>and more</strong>!</p>

<h1 id="introduction">Introduction</h1>

<h3 id="background-">Background <a class="anchor" id="background"></a></h3>

<p>In most of the other modules, we focused on field data recorded from a single electrode at the scalp (EEG) or cortical (ECoG) surface. However, typical brain voltage recordings consist of multiple electrodes. For example, the standard EEG recording consists of <a href="https://tinyurl.com/yczt58e5">21 electrodes</a> spaced across the scalp surface, and sometimes many more. The number of electrodes utilized in invasive ECoG recordings also range from a handful of contacts to over 100 implanted electrodes. In this module, we continue our study of field data recorded from the cortical surface but now consider ECoG data recorded simultaneously from two electrodes during a task.</p>

<p><a href="#introduction">Return to top</a></p>

<h3 id="case-study-data-">Case Study Data <a class="anchor" id="case-study-data"><a></a></a></h3>
<p>We conside a patient with epilepsy admitted to the hospital for <a href="https://www.ncbi.nlm.nih.gov/pubmed/25602999">resective surgery</a>. As part of her routine clinical workup before resective surgery, numerous electrodes were implanted <a href="https://en.wikipedia.org/wiki/Electrocorticography">directly on the cortical surface</a>. The purpose of this invasive recording procedure was to monitor and localize her seizures for eventual surgical treatment. During this recording procedure, in which electrocorticogram (ECoG) electrodes were implanted and recordings performed for one week, the patient volunteered to participate in an auditory task study administered by a collaborating researcher. The task required the patient to listen to individual phonemes through headphones and respond with a button click whenever she heard the <a href="http://www.jneurosci.org/content/30/49/16643">phoneme</a> “ba” (the other phonemes were different, e.g., “pa,” ”ma”). The tone presentation was repeated 100 times, and her ECoG recorded (sampling rate 500 Hz) from two cortical electrodes over the auditory brain area for 1 s.</p>

<p><a href="#introduction">Return to top</a></p>

<h3 id="goal-">Goal <a id="goal"></a></h3>
<p>Our goal is to understand the coupling between the voltage activity recorded from two brain areas during the auditory task. To do so, we compute the cross-covariance and coherence between the two electrodes. These coupling measures build upon the autocovariance, Fourier transform, and spectrum.</p>

<h3 id="tools">Tools</h3>
<p>Here you will develop an understanding for the cross-covariance and coherence measures. For the latter, we will explore and understand the Fourier transform and examine in detail the notion of phase. We also briefly discuss strategies to assess the coherence for a single trial of data.</p>

<h2 id="data-analysis-">Data Analysis <a id="data-analysis"></a></h2>

<h3 id="visual-inspection-">Visual inspection <a id="visual-inspection"></a></h3>

<p>We begin our analysis by visualizing the ECoG data. To do so, let’s load the ECoG data into Python and plot the data from the first electrode (variable <code class="highlighter-rouge">E1</code>) and second electrode (variable <code class="highlighter-rouge">E2</code>) versus time (variable <code class="highlighter-rouge">t</code>) for the first trial.</p>

<p>We begin by loading the data:</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="n">sio</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'ECoG-1.mat'</span><span class="p">)</span>
</code></pre></div></div>

<p>To understand the outcome of issuing this command, let’s examine the variable <code class="highlighter-rouge">data</code> now present in the workspace.  This variable is a <em>dictionary</em> variable (execute <code class="highlighter-rouge">type(data)</code> and the result should be <code class="highlighter-rouge">dict</code>). To see the <em>keys</em> of a dictionary, use the <code class="highlighter-rouge">keys()</code> method.</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</code></pre></div></div>

<p>The keys that start and end with two underscores ( <code class="highlighter-rouge">__</code> ) are private and contain information about the MATLAB file. The variables that we are interested in here are <code class="highlighter-rouge">E1</code>, <code class="highlighter-rouge">E2</code>, and <code class="highlighter-rouge">t</code>. These correspond to the ECoG data recorded at the two electrodes (<code class="highlighter-rouge">E1</code> and <code class="highlighter-rouge">E2</code>) as well as a time axis (<code class="highlighter-rouge">t</code>). Let’s extract these variables from the <code class="highlighter-rouge">data</code> dictionary.</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'E1'</span><span class="p">]</span>
<span class="n">E2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'E2'</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'t'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<div class="alert alert-block alert-warning">
  <p>In general, a single underscore at the beginning of a variable, function or method indicates that this object should be treated as <em>private</em>. Double underscores often indicate that Python will interpret this object with some special instructions. In both cases, for what we are doing, we can usually ignore an object that starts with an underscore.</p>
</div>

<p>Our collaborator tells us that the data from each electrode are organized as a matrix with dimensions <em>(Trials, Time)</em>. Let’s examine the shape of <code class="highlighter-rouge">E1</code>,</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E1</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div></div>

<p>We observce that the data consist of 100 trials, each consisting of 500 data points.</p>

<div class="alert alert-block alert-info">

  <p><strong>Q.</strong> Is the shape of <code class="highlighter-rouge">E2</code> similar?  HINT: It should be!</p>

</div>

<p>Let’s now plot the data in the first trial from each electrode: <a id="fig:traces"></a></p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="s">'b'</span><span class="p">)</span>            <span class="c"># Plot the data from the first trial of one electrode,</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="s">'r'</span><span class="p">)</span>            <span class="c"># ... and the first trial of the other electrode.</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Time [s]'</span><span class="p">);</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Voltage [mV]'</span><span class="p">);</span>
</code></pre></div></div>

<p>Visual inspection of the data in this trial immediately suggests a dominant rhythmic activity occurs in each recording.</p>

<div class="alert alert-block alert-info">

  <p><strong>Q.</strong> Approximate the dominant rhythmic activity in each electrode by visual inspection of the figure. A simple procedure is to count the number of peaks in each signal, then divide by the total length of the recording (in this case, 1 s). Does each electrode exhibit approximately the same rhythms? Do you observe similar results in other trials?</p>

</div>

<p>These techniques allow us to visualize the data one trial at a time. Doing so is often useful but can be time consuming, especially as the number of trials increases. Here we have 100 trials, and to visualize all of them in this way would require 100 plots. That’s not so bad, but there’s a better way. We can display the entire structure of the data across both time and trials as an image: <a id="fig:image"></a></p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">E1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>                              <span class="c">#Get the number of trials,</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span>                                   <span class="c">#... and show the image,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c">#... with meaningful axes,</span>
           <span class="n">aspect</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>                          <span class="c">#... and a nice aspect ratio.</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Time [s]'</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Trial #'</span><span class="p">);</span>
</code></pre></div></div>

<p>The resulting image for the first electrode is shown in the figure above. Voltage (in color) is plotted as a function of time along the horizontal axis and trial number along the vertical axis. This allows us to visualize the voltage activity of the first electrode for all trials at once.</p>

<p>We notice that each trial exhibits rhythmic structure, which manifests in this image as repeating undulations of blue (low voltage), then red (high voltage) over time. We also observe variability in the alignment of these rhythms from trial to trial; from one trial to the next, the undulations appear not to align.</p>

<div class="alert alert-block alert-info">

  <p><strong>Q.</strong> Display an image of the activity for the second electrode and compare it to the image from the first electrode in the figure above. How do the two compare?</p>

</div>

<p>Visual inspection of the ECoG data allows us to draw some preliminary conclusions. First, the data appear to be rhythmic, with a particularly strong oscillation near 8 Hz. That’s interesting but not the primary research objective. We would really like to understand whether the activity at the two electrodes is related. Many techniques exist to approach this problem, but let’s begin with the most basic: visual inspection. Let’s examine the activity in the first four trials, and attempt to deduce whether a consistent relation exists between the two ECoG signals across trials.</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E1</span><span class="p">[</span><span class="n">j</span><span class="p">,:],</span> <span class="s">'b'</span><span class="p">)</span>            <span class="c"># Plot the data from trial j of one electrode,</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E2</span><span class="p">[</span><span class="n">j</span><span class="p">,:],</span> <span class="s">'r'</span><span class="p">)</span>            <span class="c"># ... and trial j of the other electrode.</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">'Trial '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
</code></pre></div></div>

<p>We notice in the first two trials that the ECoG activity from the two electrodes appears nearly out of phase (i.e., when the blue curve is near a peak, the red curve is near a trough). However, for the next two trials, activity from the two electrodes nearly overlaps. From this initial visual inspection of four trials, it’s difficult to conclude whether the ECoG activity at the two electrodes is interrelated; both electrodes display rhythmic activity across all trials, but the relation between these rhythms appears to change across trials: sometimes the activities overlap, and sometimes not.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Repeat this analysis by examining additional trials, and by inspecting the activity images for each electrode. What conclusions can you make about the relations between the ECoG activity at the two electrodes? Are they related? Are they not related?</p>
</div>

<p>Although visual inspection is a useful initial tool for analyzing data, assessing the relations between two electrodes across multiple trials is a difficult task. To go further, we employ a new data analysis tool that builds from the Fourier transform: the coherence.</p>

<h3 id="autocovariance-and-cross-covariance-">Autocovariance and Cross-covariance <a id="Autocovariance-and-Cross-covariance"></a></h3>

<p>In <a href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG">Analysis of Rhythmic Activity in the Scalp EEG</a>, we defined and applied the autocovariance to a single time series and found that this measure helped reveal dependent structure in the data. We could, of course, apply the autocovariance to each ECoG time series considered here. Let’s do so, with a small update to the autocovariance formula that utilizes the trial structure of these data. We define the trial-averaged autocovariance as, <a id="eq:ac"></a></p>

<script type="math/tex; mode=display">r_{xx}\big[L\big] = \frac{1}{K} \sum_{k=1}^K \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L,k} - \bar{x}_k) (x_{n,k} - \bar{x}_k) \, ,</script>

<p>where $x_{n,k}$ indicates the data at time index $n$ and trial $k$, and $\bar{x}<em>k$ is the mean value of $x$ for trial $k$.  Notice that we include a new term $\frac{1}{K} \sum</em>{k=1}^K$, which instructs us to sum over all trials the autocovariance computed for each trial, and then divide by the total number of trials $K$.  Let’s now compute and display the trial-averaged autocovariance for the first electrode in Python<a id="fig:ac"></a>.</p>

<div class="alert alert-block alert-warning">
  <p>Note: We could instead write the trial-averaged sample autocovariance because this equation uses the observed data to estimate the theoretical covariance that we would see if we kept repeating this experiment. However, this distinction is not essential to the discussion here.</p>
</div>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>			                <span class="c"># Define the sampling interval.</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">E1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>			            <span class="c"># Define the number of trials.</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">E1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>                     <span class="c"># Define number of points in each trial.</span>
<span class="n">ac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>                  <span class="c"># Declare empty vector for autocov.</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">trial</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">E1</span><span class="p">):</span>		<span class="c"># For each trial,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">trial</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trial</span><span class="p">)</span>			<span class="c"># ... subtract the mean,</span>
    <span class="n">ac0</span> <span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>	    <span class="c"># ... compute autocovar,</span>
    <span class="n">ac</span> <span class="o">+=</span> <span class="n">ac0</span><span class="o">/</span><span class="n">K</span><span class="p">;</span>		                <span class="c"># ... and add to total, scaled by 1/K.</span>
    
<span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>                <span class="c"># Create a lag axis,</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">ac</span><span class="p">)</span>                        <span class="c"># ... and plot the result.</span>
<span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Lag [s]'</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Autocovariance'</span><span class="p">);</span>
</code></pre></div></div>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Consider the results for the trial-averaged autocovariance plotted in the figure <a href="#fig:ac">above</a>. What do these results suggest about the rhythmic structure in these data?<br /><br /></p>

  <p><strong>A:</strong> The trial-averaged autocovariance helps characterize the rhythmic activity at this electrode. Visual inspection of this figure reveals three large positive peaks. The largest peak occurs at a lag of 0 s, as expected; the signal matches itself at zero lag. The two other peaks occur at lags of approximately $\pm 0.125$ s. These peaks reveal that the data, and a version of the data shifted by +0.125 s or -0.125 s, are a good match. Notice that a shift of $\pm 0.125$ s is consistent with periodic activity of approximate frequency 1/(0.125 s) = 8 Hz. For example, imagine a sinusoid of frequency 8 Hz; if we shift the sinusoid by its period (0.125 s) and compare it to the original (unshifted) sinusoid, the match will be excellent. Our data are more complicated than a simple sinusoid, but our visual inspection of the voltage traces (<a href="#fig:traces">figure</a>) did reveal a dominant 8 Hz rhythm consistent with these autocovariance results.</p>
</div>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Repeat the analysis to compute the trial-averaged autocovariance for the second electrode. What do you find? How do the trial-averaged autocovariances for the two electrodes compare?</p>
</div>

<p>The trial-averaged autocovariance results for each electrode are interesting, but our primary scientific question for these data is whether dependent structure exists <em>between</em> the ECoG activity recorded from the two electrodes. In other words, are the time series recorded from the two electrodes coupled? Many tools exist to characterize coupling between time series, and in this module we focus on two such tools.</p>

<p>The first is the <strong>cross-covariance</strong>, $r_{xy}\big[L\big]$, an extension of the autocovariance to include two time series, defined as,</p>

<p><script type="math/tex">r_{xy}\big[L\big] = \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L} - \bar{x}) (y_{n} - \bar{y}) \, ,</script>
<a id="eq:xc"></a></p>

<p>where $x$ and $y$ are two time series with time index $n$.  Notice what we’ve done;  compared to the autocovarance defined in (<a href="#eq:ac">this equation</a>), the cross-covariance formula simply replaces the $x$’s in the second term in parentheses with $y$’s.</p>

<p>The intuition for understanding the cross-covariance is similar to that for the autocovariance (see <a href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG">Analysis of Rhythmic Activity in the Scalp EEG</a>). To calculate the cross-covariance, we multiply $y$ with $x$ shifted in time by lag $L$, as illustrated here:</p>

<p><img src="imgs/cartoon_xc.png" />&lt;/img&gt;</p>

<p>Here we show a cartoon representation of the cross-covariance between two time series $x$ and $y$. Data $x$ and $y$ are visualized as one-dimensional vectors, $x$ in black and $y$ in blue. The cross-covariance at (b) lag 0, (c) lag 1, and (d) lag 2 requires different alignments between the two vectors. To compute the cross-covariance at each lag, we multiply the overlapping elements of the two vectors, and sum the product. Non-overlapping elements are not included in the computation.</p>

<p>The cross-covariance is large at lag $L$ if the two shifted time series $x$ and $y$ match. If we’re interested in determining the coupling between $x$ and $y$, finding these matches could be particularly useful. To illustrate an application of the cross-covariance, let’s compute it between the two electrodes during the first trial of the ECoG data: <a id="fig:xc_1"></a></p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>		<span class="c"># Define one time series,</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">E2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>		<span class="c"># ... and another.</span>
<span class="n">xc</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>	        <span class="c"># ... and compute their cross covariance.</span>
<span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>            <span class="c"># Create a lag axis,</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">xc</span><span class="p">)</span>					<span class="c"># ... and plot the cross covariance vs lags in time.</span>
<span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Lag [s]'</span><span class="p">)</span>					<span class="c">#... with axes labelled.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Cross covariance'</span><span class="p">);</span>
</code></pre></div></div>

<p>Notice that we subtract the mean from each electrode in defining <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> before computing the cross-covariance using the Python function <code class="highlighter-rouge">correlate</code> from the <code class="highlighter-rouge">numpy</code> package. In this case, we supply the <code class="highlighter-rouge">correlate</code> function with three inputs, beginning with the two time series, <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>, and setting the <code class="highlighter-rouge">mode</code> to 2, which tells the function to compute the correlation over the entire extent both vectors.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Examine the cross-covariance between the ECoG data from the two electrodes in the first trial (<a href="#fig:xc_1">figure</a>). What do you observe? At what lags are the largest and smallest values of the cross-covariance? How do these results compare to the trial-averaged autocovariance in <a href="#fig:ac">this figure</a>? How do these results compare to the voltage traces from each electrode in the first trial (<a href="#fig:traces">figure</a>)?</p>
</div>

<p>Like the trial-averaged autocovariance for a single electrode (<a href="#fig:ac">here</a>), the cross-covariance between the two ECoG electrodes in the first trial reveals periodic variations (<a href="#fig:xc_1">figure</a>). To understand the structure of this cross-covariance, let’s return to the voltage traces from the two electrodes in this trial,</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="s">'b'</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">E2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="s">'r'</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Time [s]'</span><span class="p">);</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Voltage [mV]'</span><span class="p">);</span>
</code></pre></div></div>

<p>The largest peak in the cross-covariance occurs near a lag of 0.04 s. Now, imagine shifting the blue time series (corresponding to electrode 1) in this figure by 0.04 s to the left. Doing so, we find that the red and blue traces approximately match; at this lag, when one time series is positive, so is the other, and when one time series is negative, so is the other. Because of this strong match, the cross-covariance is large; the sum in (<a href="#eq:xc">this equation</a>) at this lag involves many positive terms, so $r_{xy}\big[L\big]$ is a positive number. The largest trough in the cross-covariance occurs near a lag of approximately 0.02 s. To understand this feature, imagine shifting the blue time series in the figure above by 0.02 s to the right. After this shift, the red and blue time series match, but in a different way; when one voltage trace is positive, the other is negative, and vice versa.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Continue this exercise of comparing the cross-covariance with the voltage traces in the figure above. At what lags is the cross-covariance near zero? Can you explain these points in terms of shifted versions of the ECoG traces? Can you explain the repeated appearance of peaks (and troughs) at positive and negative lags in terms of shifted versions of the ECoG traces?</p>
</div>

<p>Let’s also define the <em>trial-averaged cross-covariance</em>. The formula is similar to the trial-averaged autocovariance in (<a href="#eq:ac">this equation</a>):
<script type="math/tex">r_{xy}\big[L\big] = \frac{1}{K} \sum_{k=1}^K \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L,k} - \bar{x}_k) (y_{n,k} - \bar{y}_k) \, .</script>
<a id="eq:taxc"></a>
Notice that, compared to the trial-averaged autocovaraince in (<a href="#eq:taac">this equation</a>), we have replaced the $x$’s in the last term with $y$’s to compute the trial-averaged cross-covariance.  To implement the trial-averaged cross-covariance in Python, consider the following code.</p>

<p>For reference, let’s also plot the <strong>single-trial</strong> cross-covaraince for 4 trials,  <a id="fig:avg_xc"></a></p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">XC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>                    <span class="c"># Declare empty vector for cross cov.</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>			                <span class="c"># For each trial,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>			<span class="c"># ...get data from one electrode,</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>			<span class="c"># ...and the other electrode,</span>
    <span class="n">XC</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>         <span class="c"># ...compute cross covariance.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">XC</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>					<span class="c"># Plot cross covariance vs lags in time.</span>
<span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Lag [s]'</span><span class="p">)</span>					        <span class="c">#... with axes labelled.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Trial-averaged cross covariance'</span><span class="p">);</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">XC</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>                   <span class="c"># Also, plot the single-trial cross-covariance for 4 trials</span>
<span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Lag [s]'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Example single-trial cross covariance'</span><span class="p">);</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>               <span class="c"># Space out the subplots.</span>
</code></pre></div></div>

<p>The implementation of the trial-averaged cross-covariance is similar to the implementation of the single-trial cross-covariance. The main difference is the inclusion of the <code class="highlighter-rouge">for</code> statement, which we use to compute and store the cross-covariance of each trial. We then average these results across trials using the <code class="highlighter-rouge">mean</code> command from the <code class="highlighter-rouge">numpy</code> package. The trial-averaged cross-covariance (and example single-trial cross-covariances) are plotted in the figure above.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Compare the trial-averaged cross-covariance to the example single-trial cross-covariances. What differences and similarities do you notice between the two cross-covariances?<br />&lt;/br&gt;</p>
  <p>

<strong>A.</strong> Perhaps the most striking difference between the two cross-covariances is their magnitude; the single-trial cross-covariances are much larger—approximately an order of magnitude—than the trial-averaged cross-covariance. To understand why this difference occurs, consider the impact of averaging the four example single-trial cross-covariances plotted in the figure above. At each lag, we find both positive and negtive cross-covariance values. We therefore expect that, upon averaging these values across trials, we will obtain a value near zero at each lag. In fact, that’s just what we find in the trial-averaged cross-covariance. Because the single-trial cross-covariance functions lack alignment across trials, the averaging procedure acts to cancel out the individual (large) fluctuations of each single-trial cross-covariance.
<br />&lt;/br&gt;
&lt;p&gt;


We may therefore conclude the following. At the single-trial level we find strong cross-covariance that is periodic with period near 0.125 s (examples in the figure aove). However, we find much weaker trial-averaged cross-covariance; the cross-covariance structure that exists at the single-trial level does not persist when averaged across trials.<br />&lt;/br&gt;
&lt;p&gt;</p>

  <p>Why are the prominent cross-covariance features in the single-trial analysis lost in the trial-averaged cross-covariance? We discuss this issue in more detail in the <a href="#summary">Summary</a> below.</p>
</div>

<h3 id="trial-averaged-spectrum-">Trial-Averaged Spectrum <a id="Trial-Averaged-Spectrum"></a></h3>

<p>One goal of this module is to characterize the relations (if any) between the data recorded at the two ECoG electrodes. To do so, let’s review a vital tool in this characterization, the Fourier transform. We defined in <a href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG">Analysis of Rhythmic Activity in the Scalp EEG</a> the Fourier transfom of a signal $x$; let’s repeat that definition here,</p>

<p><script type="math/tex">X_j = \sum_{n=1}^N x_n \exp(-2 \pi i \, f_j \, t_n) \, .</script>
<a id="eq:ftCh5"></a></p>

<p>Remember that $x_n$ is the data evaluated at time index $n$. For the ECoG data of interest here, we have 1 s of data sampled at 500 Hz; therefore $n$ ranges from 1 to $N=500$, and $t_n = \mathrm{dt} \, n$ denotes the discrete time steps, where $\mathrm{dt}$ is the sampling interval. The discrete frequencies are $f_j = j/T$, where $j={-N/2+1, -N/2+2, \ldots, N/2-1, N/2}$.  Replacing the expressions for $f_j$ and $t_n$ with their definitions and simplifying, we can rewrite the equation above as,</p>

<p><script type="math/tex">X_j = \sum_{n=1}^N x_n \exp(\frac{-2 \pi i}{N} j \, n) \, .</script>
<a id="eq:ftCh5_simp"></a></p>

<p>In general, $X_j$ can be a complex quantity (i.e., the Fourier transform of $x_n$ can have both real and imaginary parts). We can therefore think of $X_j$ as residing in the two-dimensional complex plane:</p>

<p>&lt;img src=”imgs/ex_complex_plane.png”, width=300&gt;&lt;/img&gt;</p>

<p>Points in the complex plane can be specified in two coordinate systems: Cartesian coordinates (gray) or polar coordinates (orange). The <a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a> contains the real part (horizontal axis) and imaginary part (vertical axis) of every point.</p>

<p>As you may remember from a geometry or calculus class, we can represent a point in the plane using another coordinate system: polar coordinates. In polar coordinates, we imagine connecting each point to the origin. The resulting line has a length, called the radius or amplitude, and forms an angle with the real axis, called the phase. Like the real and complex parts, the amplitude and phase uniquely specify each point (almost …) in the complex plane. These two coordinate systems are shown for an example point in the complex plane in the figure above.</p>

<p>Using polar coordinates, we can then express the complex quantity $X_j$ as,</p>

<p><script type="math/tex">X_j = A_j \exp(i \phi_j) \, ,</script>
<a id="eq:x_polar"></a></p>

<p>where $A_j$ is the amplitude and $\phi_j$ is the phase at frequency index $j$.  Notice that both the amplitude and phase are functions of frequency.  Remember that, to compute the spectrum, we multiple the Fourier transform of the data by its complex conjugate, and scale the result. The spectrum of $x_n$ then becomes,</p>

<p><a id="eq:Sxx">
<script type="math/tex">% <![CDATA[
\begin{align}
S_{xx, \, j} 	&= \frac{2 \mathrm{dt}^2}{T} X_j X^*_j \label{eq:Sxx} \, , \\
		&= \frac{2 \mathrm{dt}^2}{T} \big(A_j \exp(i \phi_j) \big)  \big(A_j \exp(-i \phi_j) \big) \, ,
\end{align} %]]></script>
</a></p>

<p>where, to compute the complex conjugate in the second term, we replace $i$ with $-i$.  The last expression simplifies rather nicely,</p>

<p><script type="math/tex">% <![CDATA[
\begin{align}
S_{xx, \, j}	&= \frac{2 \mathrm{dt}^2}{T} A_j^2  \exp(i \phi_j -i \phi_j) \, , \notag \\
		&= \frac{2 \mathrm{dt}^2}{T} A_j^2  \exp(0) \, , \notag \\
		&= \frac{2 \mathrm{dt}^2}{T} A_j^2 \, .
\end{align} %]]></script>
<a id="eq:pow_A"></a></p>

<p>This expression provides a new, and perhaps more direct, interpretation of the spectrum as proportional to the squared amplitude of the point $X_j$ in the complex plane. We can extend this simplified expression in one additional way to make explicit the trial structure of the ECoG data analyzed here. Because we possess multiple trials, and we assume that each trial represents an instantiation of the same underlying process, we average the spectra across trials to compute the <em>trial-averaged spectrum</em>,</p>

<p><script type="math/tex">% <![CDATA[
<S_{xx, \, j}> = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K} \sum_{k=1}^K A_{j,k}^2 \, , %]]></script>
where $k$ indicates the trial number, $K$ the total number of trials, and $A_{j,k}$ the amplitude of the signal at frequency index $j$ and trial index $k$.  Notice how we implement the trial averaging: we simply average the squared amplitude at frequency index $j$ across the $K$ trials.  We use the angular brackets ($&lt; \, &gt;$) to denote that the spectrum ($S_{xx, \, j}$) has been averaged across trials. We can compute the trial-averaged spectrum in Python<a id="fig:trial_avg_spectrum"></a>,</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>                                         <span class="c"># Get the total duration of the recording.</span>
<span class="n">Sxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">K</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>		              <span class="c"># Create variable to store each spectrum.</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">E1</span><span class="p">):</span>				          <span class="c"># For each trial,</span>
    <span class="n">xf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> 	          <span class="c"># ... compute the Fourier transform,</span>
    <span class="n">Sxx</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">xf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">xf</span><span class="p">))</span> <span class="c"># ... and compute the spectrum.</span>
    
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>                        <span class="c"># Define a frequency axis</span>

<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>               <span class="c"># Plot average spectrum over trials in decibels vs frequency,</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>				                      <span class="c"># ... in select frequency range,</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>                                    <span class="c"># ... in select power range,</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Frequency [Hz]'</span><span class="p">)</span>	                      <span class="c"># ... with axes labelled.</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Power [ mV^2/Hz]'</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]),</span> <span class="s">'r'</span><span class="p">);</span>               <span class="c"># Also, for reference, plot spectrum from the first trial.</span>
</code></pre></div></div>

<div class="alert alert-block alert-info">
  <p><strong>Q:</strong> Are the terms frequency resolution, Nyquist frequency, and decibel familiar to you? Can you define each in words and equations?<br /><br />
<strong>A:</strong> If not, we recommend reviewing the case study in <a href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG">Analysis of Rhythmic Activity in the Scalp EEG</a>.</p>
</div>

<p>The resulting trial-averaged spectrum is shown in the figure (blue in the figure above). Compared to the example spectrum from a single trial (red in the figure above), the variability is greatly reduced. By reducing the variability in this way, interesting structure in the data may become more apparent.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong>  Upon examining the trial-averaged spectrum from one electrode, what additional conclusions can you now make about the data beyond visual inspection of the voltage traces? Repeat this computation of the trial-averaged spectrum for the second electrode. What do you find? &lt;p&gt; <em>Hint</em>: The 8 Hz peak is obvious and consistent with our visual inspection of the data. Do you notice any other (smaller) peaks in the trial-averaged spectrum?</p>
</div>

<p><a href="#introduction">Return to top</a></p>

<h1 id="introduction-to-the-coherence-">Introduction to the Coherence <a class="anchor" id="sec:coherence"></a></h1>

<p>Coherence is a measure of association between two time series. Briefly:</p>

<div class="alert alert-block alert-warning">
  <p>Two signals are coherent at some frequency if there exists a constant phase relation between them at this frequency.</p>
</div>

<p>To compute the coherence, we use the <a href="#eq:pow_A">simplified expression for the spectrum</a> and an additional term, the cross-spectrum.</p>

<p>Consider two signals $x_{n,k}$ and $y_{n,k}$, with time index $n$ and trial index $k$. These signals have corresponding Fourier transforms $X_{j,k}$ and $Y_{j,k}$. Then the trial-averaged cross-spectrum between these two signals is</p>

<p><a id="eq:cross">
<script type="math/tex">% <![CDATA[
<S_{xy,\, j}> = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K}\sum_{k=1}^K X_{j,k} Y^*_{j,k} \, , %]]></script>
</a></p>

<p>where compared to <a href="#eq:Sxx">the spectrum</a> we replace $X^<em>_j$ with $Y^</em>_j$ and include the average over the trial index $k$.  Let’s modify and clean up this expression by using polar coordinates.  To do so, we’ll first define,</p>

<script type="math/tex; mode=display">Y_{j,k} = B_{j,k} \exp(i \, \theta_{j,k}) \, ,</script>

<p>where $B_{j,k}$ is the amplitude and $\theta_{j,k}$ is the phase at frequency index $j$ and trial index $k$ for the signal $y_{n,k}$. A similar expression exists for $X_{j,k}$, with amplitude $A_{j,k}$ and phase $\phi_{j,k}$. Then, replacing $X_{j,k}$ and $Y^*_{j,k}$ in <a href="#eq:cross">the trial-averaged cross-spectrum</a> with their polar coordinate expressions, we find,</p>

<p><a id="eq:cross_spectrum">
<script type="math/tex">% <![CDATA[
<S_{xy,\, j}> = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K} \sum_{k=1}^K A_{j,k} B_{j,k} \exp \big( i \Phi_{j,k} \big) \, , %]]></script>
</a></p>

<p>where we have defined the <em>phase difference</em> between the two signals as $\Phi_{j,k} = \phi_{j,k} - \theta_{j,k}$. This equation is the trial-averaged cross spectrum of the two signals $x_{n,k}$ and $y_{n,k}$.  We note that the trial-averaged cross spectrum ($&lt;S_{xy,\, j}&gt;$) can be complex (i.e., may have nonzero real and imaginary parts).</p>

<p>At last we define the <strong>coherence</strong>,</p>

<p><a id="eq:cohr">
<script type="math/tex">% <![CDATA[
\kappa_{xy,\, j} = \frac{ \mid <S_{xy,\, j}> \mid }{ \sqrt{<S_{xx, \, j}>} \sqrt{<S_{yy, \, j}>}} \, , %]]></script>
</a></p>

<p>where $\mid &lt;S_{xy,\, j}&gt; \mid$ indicates the magnitude of the trial-averaged cross spectrum.  In words, the coherence is the magnitude of the trial-averaged cross spectrum between the two signals at frequency index $j$ divided by the magnitude of the trial-averaged spectrum of each signal at frequency index $j$.</p>

<p>To further our understanding of the mathematical expression of the coherence in <a href="#eq:cohr">the equation above</a>, let’s replace the trial-averaged spectra in the numerator and denominator with their corresponding expressions in polar coordinates,</p>

<p><a id="eq:cohr_ang">
<script type="math/tex">\kappa_{xy,\, j} = \frac { \biggr\lvert \sum\limits_{k=1}^K A_{j,k} B_{j,k} \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			       { \sqrt{\sum\limits_{k=1}^K A_{j,k}^2} \,  \sqrt{\sum\limits_{m=1}^K B_{j,m}^2} }</script>
</a></p>

<p>This expression is complicated.  So, to gain some intuition for the behavior of $\kappa_{xy,\, j}$, let’s make the simplifying assumption that at each frequency the amplitude is identical for both signals and all trials, that is, $A_{j,k} = B_{j,k} = C_j$.  Notice that, in using only the expression $C_j$ for the amplitude, we’ve eliminated the trial index $k$, and only preserved the frequency index $j$. With this simplifying assumption, our expression for the coherence becomes,</p>

<p><a id="eq:cohr_simp">
<script type="math/tex">% <![CDATA[
\begin{align}
\kappa_{xy,\, j} &= \frac { \biggr\lvert \sum\limits_{k=1}^K C_j \, C_j \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			         { \sqrt{\sum\limits_{k=1}^K C_j^2}  \sqrt{\sum\limits_{m=1}^K C_j^2} } \, , \notag \\
		    &= \frac{ C_j^2 }{ C_j^2 } \frac{\biggr\lvert \sum\limits_{k=1}^K \exp \big( i \Phi_{j,k} \big) \biggr\rvert}{\sqrt{\sum\limits_{k=1}^K 1}  \sqrt{\sum\limits_{m=1}^K 1} } \, , \notag \\
		    &= \frac{ 1 }{ K }\biggr\lvert \sum_{k=1}^K \exp \big( i \Phi_{j,k} \big) \biggr\rvert \, .
\end{align} %]]></script>
</a></p>

<p>Under the simplifying assumption that the amplitude is identical at each frequency for both signals and all trials, the coherence simplifies to the last equation in the expression above. In this special case, the expression for the coherence only involves the phase difference between the two signals averaged across trials; the amplitudes in the numerator and denominator have canceled out.</p>

<p>Now, let’s interpret the simplified expression for the coherence. To do so, we consider two scenarios.</p>

<h2 id="simple-scenario-1--phases-align-across-trials-">Simple Scenario 1:  Phases align across trials <a id="Simple_Scenario_1"></a></h2>

<p>First, we assume that at a specific frequency index $j$, the two signals possess a <em>constant</em> phase difference across trials. Under this assumption, the phase difference in the first trial ($\Phi_{j,1}$) equals the phase difference in the second trial ($\Phi_{j,2}$), which equals the phase difference in the third trial ($\Phi_{j,3}$), and so on for all trials.  To denote this equivalence in the phase difference across trials, let’s replace the symbol for the phase difference $\Phi_{j,k}$ with $\Phi_{j,0}$; here, we have replaced the subscript $k$ with the subscript $0$ to remind ourselves that the phase difference does not depend upon the choice of trial. Now consider the expression:</p>

<script type="math/tex; mode=display">\exp \big( i \Phi_{j,0} \big) \, . \notag</script>

<p>This term defines a point in the complex plane with amplitude 1, which we can visualize as a vector leaving the origin at angle $\Phi_{j,0}$ to the real axis. Consider, for example, the leftmost plot in the figure below:
<img src="imgs/ex_complex_plane_coherence_a.png" />&lt;/img&gt;</p>

<p>In this cartoon illustration of the complex plane, we plot the phase difference for each trial (orange arrow). In this case, the phase difference is the same across all trials.</p>

<p>The summation of these terms across trials then becomes,</p>

<script type="math/tex; mode=display">\sum_{k=1}^K \exp \big( i \Phi_{j,0} \big) \, . \notag</script>

<p>This expression defines a sum of vectors in the complex plane, each of radius 1 (indicated by the blue circle in the figure). Because the phase difference is the same for each trial, these vectors point in the same direction for each trial. Then by summing up these vectors end to end across trials, we produce a long vector in the complex plane that terminates far from the origin, as shown in the righmost panel of the figure above.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q:</strong> How long is the summed vector in this case?<br />&lt;/br&gt;</p>
  <p>

<strong>A:</strong> We add $K$ vectors (one for each trial) each of length 1, and each pointing in the same direction ($\Phi_{j,0}$).  So the total length of the vector (i.e., the total distance from the origin to the termination point of the summed vector) is $K$.
&lt;/div&gt;

The <a href="#eq:cohr_simp">coherence</a> is this vector length, divided by $K$, so we conclude in this case that,

<script type="math/tex">\kappa_{xy,\, j} = 1 \, , \notag</script>

which indicates strong coherence between the two signals.  The strong coherence in this case results from the constant phase relationship between the two signals across trials at frequency index $j$.

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q:</strong> Does the conclusion $\kappa_{xy,\, j} = 1$ depend upon the value of the phase difference $\Phi_{j,0}$?  For example, does this result require that the phase difference between the two signals in each trial ($\Phi_{j,0}$) equal $0$, or $\pi/4$, or $\pi$?
&lt;/div&gt;

<a href="#introduction">Return to top</a>

## Simple Scenario 2: Phases are random across trials <a id="Simple_Scenario_2"></a>

As a second scenario, consider another specific frequency $j$ in which the two signals have a random phase difference in each trial. In this case, the phase difference can assume any value between $0$ and $2\pi$ for each trial. To visualize this, let’s imagine the phase differences in the complex plane; in this scenario, the vectors point in different (random) directions from trial to trial:

<img src="imgs/ex_complex_plane_coherence_b.png" />&lt;/img&gt;

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q:</strong> Consider the sum of these vectors end to end in the complex plane, plotted in the rightmost panel of the figure above. What is the approximate length of this summed vector across trials?
&lt;p&gt;

<strong>A:</strong> We expect the length of this vector to be small. Because the angles lack organization from trial to trial, the vectors are equally likely to point in any direction. Therefore, when we sum these vectors across trials, the length fails to accumulate in any particular direction.
&lt;/div&gt;

Under the simplifying assumption that the amplitude is identical at this frequency for both signals and all trials, the <a href="#eq:cohr_simp">coherence</a> is this summed vector length, divided by $K$. Our visual inspection of the cartoon in the figure above (rightmost panel) suggests that this summed vector length will be small. Therefore, for this scenario we conclude that,

<script type="math/tex">\kappa_{xy,\, j} \approx 0 \, , \notag</script>

which indicates weak coherence between the two signals.  The weak coherence in this case results from the random phase relationship over trials between the two signals.

# Summary of the coherence <a id="Summary_of_the_coherence"></a>

These two examples illustrate in simplified scenarios the behavior of the coherence. To summarize, the <a href="#eq:cohr">coherence</a> is a measure of the relationship between $x$ and $y$ at the same frequency.  The coherence ranges between 0 and 1,

<script type="math/tex">0 \leq \kappa_{xy,\, j}  \leq 1 \, , \notag</script>

in which:
- $0$ indicates no coherence between signals $x$ and $y$ at frequency index $j$, and
- 1 indicates strong strong coherence between signals $x$ and $y$ at frequency index $j$.

&lt;div class="alert alert-block alert-warning"&gt;
    The coherence is a measure of the phase consistency between two signals at frequency index $j$ across trials.
&lt;/div&gt;

We note that because computing the coherence requires the Fourier transform, the notions of frequency resolution and Nyquist frequency are identical to those for the spectrum. In other words, the frequency resolution of the coherence is $1/T$, and the Nyquist frequency is half of the sampling frequency; see <a href="https://github.com/Mark-Kramer/Case-Studies-Python/tree/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG">Analysis of Rhythmic Activity in the Scalp EEG</a> for details.

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q.</strong> What are the units of the coherence?
&lt;p&gt;Hint: Consider <a href="#eq:cohr">this equation</a> for coherence and the units of the terms in the numerator and denominator. You should find that the coherence is unitless.
&lt;/div&gt;

<a href="#introduction">Return to top</a>

## Cross-Covariance and Cross-Spectrum <a id="cc_and_cs"></a>
Although we defined the cross-spectrum in <a href="#eq:cross">this equation</a> and used it to define the coherence in <a href="#eq:cohr">this equation</a>, the cross-spectrum may appear somewhat unmotivated. Fortunately, there is additional insight to be gained. We show <a href="https://github.com/Mark-Kramer/Case-Studies-Python/blob/master/Analysis%20of%20Rhythmic%20Activity%20in%20the%20Scalp%20EEG/Supplement.%20Intuition%20behind%20the%20power%20spectral%20density.ipynb">here</a> that the spectrum is the Fourier transform of the autocovariance. Conceptually, the spectrum and autocovariance provide a frequency domain and time domain measure of a signal’s rhythms, respectively. In the same way, the cross-spectrum and cross-covariance are partners. 

&lt;div class="alert alert-block alert-warning"&gt;
The cross-spectrum is the Fourier transform of the cross-covariance.
&lt;/div&gt;

The cross-spectrum and cross-covariance form a Fourier transform pair. The cross-spectrum is a frequency domain measure of coupling, while the cross-covariance is a time domain measure of coupling. To move back and forth between these two measures, we use the Fourier transform. In practice, we rarely examine the cross-spectrum directly; it’s a complex quantity and so requires two dimensions (i.e., the complex plane) to visualize. However, the cross-spectrum is fundamental to the coherence, so in that sense it’s an important actor in the analysis.


<a href="#introduction">Return to top</a>

## Computing the Coherence <a id="computing_coherence"></a>
With that introduction, we are now equipped to compute the coherence. We expect the coherence to reveal the frequencies at which the two ECoG signals exhibit a constant phase relation across trials.

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q.</strong> Before we compute the coherence, hypothesize whether you expect to observe coherence between the two ECoG signals. If so, at what frequencies? Your hypothesis should be based on the previous visual analysis and spectral analysis of these data (see, for example, <a href="#fig:traces">this figure</a> and <a href="#fig:trial_avg_spectrum">this figure</a>).
&lt;/div&gt;

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q.</strong> To plot the coherence versus frequency, we must identify the frequency resolution and Nyquist frequency appropriate for the analysis of the ECoG data. What are they?
&lt;/div&gt;

There are a variety of alternatives to compute the coherence. To start, let’s compute the coherence by hand. The reason for doing so is that we can implement the preceding mathematical expressions and in that way gain more understanding of their features. Here’s the Python code<a id="fig:cohr"></a>:



{:.input_area}
<code class="highlighter-rouge">python
Sxx = np.zeros([K,int(N/2+1)])		              # Create variables to save the spectra,
Syy = np.zeros([K,int(N/2+1)])
Sxy = np.zeros([K,int(N/2+1)], dtype=complex)
for k in range(K):			                      # For each trial,
    x=E1[k,:]-np.mean(E1[k,:])                    # Get the data from each electrode,
    y=E2[k,:]-np.mean(E2[k,:])
    xf  = np.fft.rfft(x-np.mean(x))               # ... compute Fourier transform,
    yf  = np.fft.rfft(y-np.mean(y))
    Sxx[k,:] = 2*dt**2/T *np.real(xf*np.conj(xf)) # ... and compute the spectra.
    Syy[k,:] = 2*dt**2/T *np.real(yf*np.conj(yf))
    Sxy[k,:] = 2*dt**2/T *       (xf*np.conj(yf))

Sxx = np.mean(Sxx,0)		                      # Average the spectra across trials,
Syy = np.mean(Syy,0)
Sxy = np.mean(Sxy,0)

cohr = np.abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))# ... and compute the coherence.

plot(f, cohr);		                              # Plot coherence vs frequency,
xlim([0, 50])			                          # ... in chosen frequency range,
ylim([0, 1])                                      # ... with y-axis scaled,
xlabel('Frequency [Hz]')                          # ... and with axes labelled.
ylabel('Coherence');
</code>


&lt;div class="alert alert-block alert-info"&gt;
<strong>Q.</strong> That’s quite a bit of code. Look through it line by line, and confirm that each step makes sense. Can you identify the calculation of the cross-spectrum? of the trial averaging?
&lt;/div&gt;

&lt;div class="alert alert-block alert-info"&gt;
<strong>Q:</strong> Consider the coherence between the two ECoG electrodes plotted in the figure above. At what frequencies do strong coherences appear? How do these frequencies compare to the trial-averaged spectra, shown for one electrode in <a href="#fig:trial_avg_spectrum">this figure</a>?<br />&lt;/br&gt;
&lt;p&gt;</p>

  <p><strong>A:</strong> The coherence measures the phase consistency at a chosen frequency between two signals across trials. For the ECoG data, both electrodes possess trial-averaged spectra with similar features: a large peak near 8 Hz and a smaller peak near 24 Hz (see the trial-averaged spectrum for one electrode in <a href="#fig:trial_avg_spectrum">this figure</a>). However, the coherence between the two ECoG signals reveals a peak only at 24 Hz. We conclude that the two ECoG signals both exhibit a dominant oscillation at 8 Hz, yet this rhythm is not coherent across trials; only the smaller-amplitude rhythm at 24 Hz is coherent between the two electrodes.</p>
</div>

<h2 id="visualizing-the-phase-difference-across-trials-">Visualizing the Phase Difference across Trials <a id="Visualizing_the_Phase_Difference"></a></h2>

<p>The coherence results suggest for the two ECoG recordings a constant phase relation across trials at 24 Hz and a random phase relation across trials at 8 Hz. To further explore these relations, let’s visualize the distribution of phase differences at the two frequencies, as implemented in the following Python code:</p>

<div class="language-python input_area highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">j8</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">==</span><span class="mi">8</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>	         <span class="c"># Determine index j for frequency 8 Hz.</span>
<span class="n">j24</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span><span class="o">==</span><span class="mi">24</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>	         <span class="c"># Determine index j for frequency 24 Hz.</span>

<span class="n">phi8</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>		             <span class="c"># Variables to hold phase differences.</span>
<span class="n">phi24</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>			         <span class="c"># For each trial, compute the cross spectrum. </span>
    <span class="n">x</span><span class="o">=</span><span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E1</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>       <span class="c"># Get the data from each electrode,</span>
    <span class="n">y</span><span class="o">=</span><span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E2</span><span class="p">[</span><span class="n">k</span><span class="p">,:])</span>
    <span class="n">xf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># ... compute the Fourier transform,</span>
    <span class="n">yf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">Sxy</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">T</span> <span class="o">*</span><span class="p">(</span><span class="n">xf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">yf</span><span class="p">))</span><span class="c"># ... and the cross-spectrum,</span>
    <span class="n">phi8</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Sxy</span><span class="p">[</span><span class="n">j8</span><span class="p">])</span>	 <span class="c"># ... and the phases.</span>
    <span class="n">phi24</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Sxy</span><span class="p">[</span><span class="n">j24</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                   <span class="c"># Plot the distributions of phases.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">phi8</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Counts'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Angles at 8 Hz'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">phi24</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Angles at 24 Hz'</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">'Counts'</span><span class="p">)</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">'Phase'</span><span class="p">);</span>
</code></pre></div></div>

<p>Again, we’re encountering quite a bit of Python code. Fortunately, large chunks of this code are familiar. We reuse useful quantities, like the number of trials (<code class="highlighter-rouge">K</code>) and the frequency axis (<code class="highlighter-rouge">f</code>). Then, within the frequency axis variable (<code class="highlighter-rouge">f</code>), we use the function <code class="highlighter-rouge">np.where</code> to identify the indices corresponding to a frequency of 8 Hz and a frequency of 24 Hz. For each trial, we then compute the cross-spectrum (<code class="highlighter-rouge">Sxy</code>). The cross-spectrum is a complex quantity at each frequency, and we identify the angle in the complex plane corresponding to the frequencies 8 Hz and 24 Hz using the Python function <code class="highlighter-rouge">np.angle</code>. We store these results in two vectors, <code class="highlighter-rouge">phi8</code> and <code class="highlighter-rouge">phi24</code>.</p>

<p>To summarize the results, we plot a histogram of the phase differences. We divide the phase axis into 20 bins of equal size from 0 to 2$\pi$ radians, or equivalently, 0 to 360 degrees. At 8 Hz, we observe that phase differences appear in all angular intervals; notice that the number of phase differences located in each angular interval remains small, typically less than 10. At 24 Hz, the angular differences concentrate near 0 degrees; all of the angles lie between  approximately 60 and 60 degrees. This visualization is consistent with the strong coherence at 24 Hz, indicative of a consistent phase difference across trials between the two electrodes.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q.</strong> Compute and display the distribution of phase differences at other frequencies. What do you find? Are these results consistent with the coherence plotted in <a href="#fig:cohr">this figure</a>?</p>
</div>

<h2 id="single-trial-coherence-">Single-Trial Coherence <a id="single_trial_coherence"></a></h2>

<p>We have emphasized that coherence is a measure of phase consistency between two signals at some frequency <em>across trials</em>. This type of analysis is appropriate in many instances in which data are collected in a trial structure. However, we might also be interested in computing the coherence between two signals recorded in a single observation or trial.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q:</strong> Is it possible? Can we compute the coherence between two signals for a single trial?</p>
</div>

<p>To address this question, consider the <a href="#eq:cohr_ang">equation for the coherence written in polar coordinates</a>.  Remember that, in writing this equation, we have made no assumptions about the data;  instead, all we have done is express the complex quantities in polar coordinates.  Now consider this equation for the case in which we possess only one trial, so that $K=1$.  Then,</p>

<script type="math/tex; mode=display">\kappa_{xy,\, j} = \frac { \biggr\lvert A_{j,1} B_{j,1} \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			       { \sqrt{A_{j,1}^2}  \sqrt{B_{j,1}^2} }
		     = \biggr\lvert \exp \big( i \Phi_{j,k} \big) \biggr\rvert = 1 \, .</script>

<p>So, we find here perfect coherence ($\kappa_{xy,\, j}=1$) for any choice of signals $x$ and $y$ and for any frequency (index $j$).  For example, we could choose $x$ to be the price of a publicly traded stock (e.g., GE) and $y$ to be an ECoG recording, both sampled at 500 Hz for 1 s.  Even in this case, we will find perfect coherence between the two signals.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q:</strong> Can we use an ECoG signal to predict the stock price of GE? If so, then we’re rich! How can any two arbitrary signals be perfectly coherent at all frequencies?</p>
</div>

<p>The answer is that the coherence measure requires a trial structure. Recall that the coherence measures the phase consistency between two signals <em>across trials</em>. If only one trial is observed, then the two signals are trivially coherent; the two signals have some phase difference between 0 and 2$\pi$ and because we have no other trials with which to compare this difference, the two signals are “coherent.”</p>

<p>But what if we only collect one trial of data? We can still attempt to compute the coherence in (at least) two ways. First, we could divide the single trial of data into smaller intervals and then treat each interval as a trial. This approach can be effective if we believe the phase relation persists in time, and if we possess a long enough recording. Note that by dividing the data into smaller intervals, we impact the frequency resolution.</p>

<div class="alert alert-block alert-info">
  <p><strong>Q:</strong> Imagine we collect 10 s of ECoG data (sampling frequency 500 Hz) from two electrodes and would like to compute the coherence. To do so, we divide the data into ten nonoverlapping 1 s intervals, and treat each interval as a trial to compute the coherence. What is the frequency resolution of the coherence? If instead we divide the data into 100 nonoverlapping frequency intervals, what is the frequency resolution? In both cases, what is the Nyquist frequency?</p>
</div>

<p>A second approach to compute the coherence from a single trial of data is to use the <a href="https://en.wikipedia.org/wiki/Multitaper">multitaper method</a>. In this case, each taper acts like a trial. Therefore, to acquire more trials for an accurate estimate of the coherence, we include more tapers. But, by increasing the number of tapers, we worsen the frequency resolution. Because the ECoG data of interest here consist of multiple trials, we do not focus on measures of single-trial coherence.</p>

<h2 id="relation-between-statistical-modeling-and-coherence-">Relation between Statistical Modeling and Coherence <a id="Relation_between_Statistical_Modeling_and_Coherence"></a></h2>

<p>Before concluding the discussion of coherence, let’s briefly consider a complementary statistical modeling approach. In developing this statistical model, our goal is to capture the (linear) relation between two signals $x$ and $y$ observed simultaneously for multiple trials. We begin by proposing a statistical model that predicts one signal ($y$) as a linear function of the other ($x$):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
y_n	&= \sum\limits_{m = -\infty}^{\infty} \beta_m x_{n-m} + \epsilon_n \, , \\
	&= (\beta \star x)\big[n\big] + \epsilon_n \, ,
\end{align*} %]]></script>

<p>where we express the predicted signal ($y_n$) as a function of $x_n$, coefficients $\beta_m$, and a Gaussian noise term $\epsilon_n$, and where $n$ is a discrete time index.  Notice that, in the first equation, the summation limits indicate that the predicted signal at time index $n$ may depend on $x$ at any past or future time.  The second equality above expresses the summed product of $\beta$ and $x$ as their convolution.  Taking the Fourier transform of both sides of this equation, and noting that convolution in the time domain is equivalent to multiplication in the frequency domain, we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
Y_j	&= \gamma_j X_j + \Upsilon_j \, ,
\end{align*} %]]></script>

<p>where $Y_j$ is the Fourier transform of $y_n$,
	$\gamma_j$ is the Fourier transform of $\beta_n$,
	$X_j$ is the Fourier transform of $x_n$,
	$\Upsilon_j$ is the Fourier transform of $\epsilon_n$,
and $j$ indicates a discrete frequency index.  Multiplying both sides of this equation by the complex conjugate of the Fourier transform of $x$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
Y_j \, X_j^*	&= \gamma_j X_j \, X_j^*+ \Upsilon_j \, X_j^* \, ,
\end{align*} %]]></script>

<p>and averaging this result across the trials of data, we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
< Y_j \, X_j^* >	&= \gamma_j < X_j \, X_j^*> + < \Upsilon_j \, X_j^*> \, ,
\end{align*} %]]></script>

<p>where we have used the notation $&lt; \, &gt;$ to indicate the trial average.
Assuming that the noise term and signal $x$ are unrelated, their trial average is zero (i.e.,  $ &lt; \Upsilon_j \, X_j^*&gt; = 0$).  Solving for $\gamma_j$ we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\gamma_j  	&= \dfrac{< Y_j \, X_j^* >}{< X_j \, X_j^*>} \, , \notag \\
			&= \dfrac{< S_{xy,j} >}{< S_{xx,j} >} \, . \label{eq:model_coherence}
\end{align} %]]></script>

<p>Then, comparing this expression to the <a href="#eq:cohr">equation for coherence</a> we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\kappa_{xy,\, j} =  \mid \gamma_j \mid \dfrac{\sqrt{<S_{xx, \, j}>}}{\sqrt{<S_{yy, \, j}>}} \, .
\end{align} %]]></script>

<p>We conclude that the coherence ($\kappa_{xy,\, j}$) is a scaled version of the frequency domain representation of the statistical model coefficients ($\gamma_j$) for predicting $y$ from $x$. We note that $\gamma_j$ is a complex quantity that allows us to model both the magnitude and phase of the relationship between $x$ and $y$.  The phase difference computed from the model and the coherence is the same as well.</p>

<h1 id="summary-">Summary <a id="summary"></a></h1>

<p>In this module, we analyzed ECoG data recorded from two electrodes during an auditory task. The task involved the repeated presentation of auditory stimuli, resulting in 100 trials of 1 s duration recorded simultaneously from the two electrodes. We began the analysis with visual inspection of individual trials and of all trials at once. Then, to assess the relations between the two recordings, we computed the cross-covariance. We discussed how the cross-covariance is an extension of the autocovariance, and found that the single-trial cross-covariance between the ECoG signals exhibited periodic structure, consistent with rhythmic coupling of period 0.125 s. However, the trial-averaged cross-covariance provided less evidence for consistent rhythmic coupling across trials. We then computed the trial-averaged spectrum and found a large peak near 8 Hz and a much smaller peak near 24 Hz.</p>

<p>To further assess the relation between the two electrodes, we computed the coherence. The coherence is strong (approaches 1) at a chosen frequency $f_0$ when there exists a constant phase relation at frequency $f_0$ between two electrodes over trials. We found a strong coherence between the two ECoG electrodes only at 24 Hz. We concluded that although both ECoG signals possessed dominant rhythms at 8 Hz, these rhythms were not coherent between the two electrodes. The strong coherence appeared only at the small-amplitude 24 Hz rhythm. Finally, we implemented a technique to visualize the distribution of phase differences between the two electrodes across trials, and provided some suggestions for how to compute the coherence for a single trial of data.</p>

<div class="alert alert-block alert-warning">
  <p><strong>Caution!</strong> Large amplitude does not imply large coherence.</p>
</div>

<p>In this example, only the coherence revealed the low-amplitude coupling at 24 Hz between the two ECoG electrodes. This coupling was not obvious in the single-trial or trial-averaged cross-covariance. In fact, the single-trial cross-covariance was deceiving; we found <a href="#fig:xc_1">strong single-trial cross-covariance</a> with period 0.125 s, or 8 Hz, yet no coherence at 8 Hz.</p>

<p>To understand this discrepancy, consider two unrelated signals, each dominated by the same rhythm. By unrelated we mean that the signals do not communicate in any way. Yet both are rhythmic and happen to oscillate at the same frequency. If we compute the cross-covariance between these two unrelated signals, we will find periodic lags at which the two signals nearly overlap and the cross-covariance is large. The period of these cross-covariance peaks corresponds to the period of the common rhythm shared by the two signals. Here the periodic, large cross-covariance values occur because the two signals happen to both exhibit a similar rhythm, not because one signal influences the other.</p>

<p>This example illustrates a point of caution in the interpretation of cross-covariance results. Unrelated signals that happen to share a similar dominant rhythm will exhibit large periodic structure in the cross-covariance. One approach to defend against such cross-covariance results is to compute the trial-averaged cross-covariance. If two signals are unrelated—to one another and to the trial structure—then we do not expect similar cross-covariance functions across trials. Therefore, although each single-trial cross-covariance may have large values at some lags, their average across trials will be small. This is <a href="#fig:avg_xc">just what we found</a> for the ECoG data examined here. We note that the unrelated 8 Hz signals, which dominate the ECoG activity at each electrode, mask the much smaller amplitude 24 Hz activity that is coupled between the two electrodes. The coupling at 24 Hz is not apparent in the <a href="#fig:avg_xc">trial-averaged cross-covariance</a>. The coherence, which normalizes by the power at each frequency, uncovers this relation.</p>

<p>As is true for the Fourier transform and spectrum, there exists a vast literature on computing and interpreting the coherence. Some references for further reading include:</p>

<ul>
  <li>
    <p><a href="https://www.cambridge.org/core/books/spectral-analysis-for-physical-applications/A9195239A8965A2C53D43EB2D1B80A33">Percival &amp; Walden, 1993</a></p>
  </li>
  <li>
    <p><a href="https://www.elsevier.com/books/spectral-analysis-and-time-series-two-volume-set/priestley/978-0-08-057055-6">Priestly, 1982</a></p>
  </li>
  <li>
    <p><a href="http://numerical.recipes/">Numerical recipes</a></p>
  </li>
</ul>

              <nav class="c-page__nav">
  
    
    <a id="js-page__nav__prev" class="c-page__nav__prev" href="/Case-Studies-Python/03/supplement-2">
      〈 <span class="u-margin-right-tiny"></span> Intuition behind the power spectra...
    </a>
  

  
    
    <a id="js-page__nav__next" class="c-page__nav__next" href="">
       <span class="u-margin-right-tiny"></span> 〉
    </a>
  
</nav>

            </div>
          </div>
        </div>
      </main>
    </div>

  </body>
</html>
